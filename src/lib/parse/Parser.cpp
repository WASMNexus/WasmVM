/** generated by ParGen **/
#include "Parser.hpp"

#include <stack>
#include <list>
#include <variant>
#include <vector>
#include <algorithm>
#include <array>

namespace WasmVM {

using namespace Tokens;

Parser::Parser(Lexer& lexer) : lexer(lexer) {}

std::pair<Parser::term_t, Parser::token_t> Parser::fetch(){
    if(!buffer.empty()){
        auto token = buffer.front();
        buffer.pop_front();
        return token;
    }
    Token res = lexer.get();
    return {res.index() + 1, res};
}

static WasmModule action_1(std::vector<Position> _pos, Tokens::ParenL _op0, Tokens::Module _op1, Tokens::ParenR _op2){
    return WasmModule();
}
static WasmModule action_2(std::vector<Position> _pos, Tokens::ParenL _op0, Tokens::ParenR _op1){
    return WasmModule();
}
static WasmModule action_3(std::vector<Position> _pos){
    return WasmModule();
}

std::vector<Parser::State> Parser::table = {
    {{1, {{3,{}},}},{2, {{5,{}},}},{233, {{7,{}},}},},
    {{1, {{6,{1,}},}},},
    {{3, {{9,{}},}},{10, {{11,{}},}},},
    {{1, {{0,{}},}},},
    {{1, {{4,{1,1,}},}},},
    {{3, {{13,{}},}},},
    {{1, {{2,{1,1,1,}},}},},
};

WasmModule Parser::parse(){
    // Prepare
    std::stack<Stack::iterator> branches;
    Stack stack;
    stack.push(fetch(), 0);
    auto throw_error = [&](term_t term){
        if(branches.empty()){
            throw ParseError(term);
        }
        auto& saved = branches.top();
        auto buf_top = buffer.begin();
        for(auto it = stack.begin(); it != saved; it = std::next(it)){
            if(std::holds_alternative<token_t>(it->elem)){
                buffer.emplace(buf_top, it->term, std::get<token_t>(it->elem));
            }else{
                auto flattened = std::get<Node>(it->elem).flatten();
                buffer.insert(buf_top, flattened.begin(), flattened.end());
            }
        }
        saved->branch += 1;
    };
    // Parse
    while(stack.front().state != End){
        Entry& entry = stack.front();
        State& state = table[entry.state];
        if(state.contains(entry.term)){
            std::vector<Act>& acts = state[entry.term];
            if(entry.branch == 0){
                if(acts.size() > 1){
                    branches.emplace(stack.begin());
                }
            }else if(entry.branch == acts.size() - 1){
                branches.pop();
            }
            Act& act = acts[entry.branch];
            if(act.first & 1){ // Shift
                stack.push(fetch(), act.first >> 1);
            }else{ // Reduce
                if(std::holds_alternative<token_t>(entry.elem)){
                    buffer.emplace_front(entry.term, std::get<token_t>(entry.elem));
                    stack.pop_front();
                }
                stack.reduce(act.first >> 1, act.second);
            }
        }else{
            throw_error(entry.term);
        }
    }
    // Expand tree
    return expand_tree(stack.back());
}

void Parser::Stack::reduce(size_t action, std::vector<bool> param_toggle){
    static const std::vector<term_t> signatures {233,233,233,};
    if(action == 0){
        emplace_front(Entry {.term = 0, .state = End});
        return;
    }
    Node node = {.action = action, .param_toggle = param_toggle};
    size_t param_count = std::count_if(param_toggle.begin(), param_toggle.end(), [](bool val){return val;});
    for(size_t i = 0; i < param_count; ++i){
        node.children.emplace_front(front());
        pop_front();
    }
    Entry* head = &node.children.front();
    while(std::holds_alternative<Node>(head->elem)){
        Node& child = std::get<Node>(head->elem);
        head = &child.children.front();
    }
    Entry& entry = emplace_front();
    entry.term = signatures[action - 1];
    entry.state = head->state;
    entry.elem.emplace<Node>(node);
}

using item_t = std::variant<std::monostate,
    Parser::token_t,
    WasmModule
>;

WasmModule Parser::expand_tree(Entry& tree){
    std::list<std::variant<Node, token_t>> entry_stack;
    std::list<std::pair<Position, item_t>> param_stack;
    auto extract_entry = [&](Entry& entry){
        if(std::holds_alternative<token_t>(entry.elem)){
            entry_stack.emplace_front(std::get<token_t>(entry.elem));
        }else if(std::holds_alternative<Node>(entry.elem)){
            Node& elem = std::get<Node>(entry.elem);
            Node& node = std::get<Node>(entry_stack.emplace_front(Node {.action = elem.action, .param_toggle = elem.param_toggle}));
            node.children.swap(elem.children);
        }
    };
    extract_entry(tree);
    auto invoke_action = [&](Node& node){
        std::vector<Position> positions(node.param_toggle.size());
        std::vector<item_t> params(node.param_toggle.size());
        Position pos;
        for(size_t i = node.param_toggle.size(); i > 0; --i){
            size_t index = i - 1;
            if(node.param_toggle[index]){
                positions[index] = param_stack.front().first;
                params[index] = param_stack.front().second;
                param_stack.pop_front();
            }
        }
        for(size_t i = 0; i < node.param_toggle.size(); ++i){
            if(node.param_toggle[i]){
                pos = positions[i];
                break;
            }
        }
        switch(node.action){
            case 1: 
                param_stack.emplace_front(pos, action_1(positions,
                    node.param_toggle[0] ? std::get<Tokens::ParenL>(std::get<Token>(params[0])) : Tokens::ParenL(),
                    node.param_toggle[1] ? std::get<Tokens::Module>(std::get<Token>(params[1])) : Tokens::Module(),
                    node.param_toggle[2] ? std::get<Tokens::ParenR>(std::get<Token>(params[2])) : Tokens::ParenR()
                ));
            break;
            case 2: 
                param_stack.emplace_front(pos, action_2(positions,
                    node.param_toggle[0] ? std::get<Tokens::ParenL>(std::get<Token>(params[0])) : Tokens::ParenL(),
                    node.param_toggle[1] ? std::get<Tokens::ParenR>(std::get<Token>(params[1])) : Tokens::ParenR()
                ));
            break;
            case 3: 
                param_stack.emplace_front(pos, action_3(positions
                ));
            break;
            default:
            break;
        }
    };
    while(!entry_stack.empty()){
        std::variant<Node, token_t>& entry = entry_stack.front();
        if(std::holds_alternative<token_t>(entry)){
            token_t token = std::get<token_t>(entry);
            param_stack.emplace_front(token.pos, token);
            entry_stack.pop_front();
        }else if(std::holds_alternative<Node>(entry)){
            Node& node = std::get<Node>(entry);
            if(node.children.size() > 0){
                for(auto it = node.children.rbegin(); it != node.children.rend(); it = std::next(it)){
                    extract_entry(*it);
                }
                node.children.clear();
            }else{
                invoke_action(node);
                entry_stack.pop_front();
            }
        }
    }
    return std::get<WasmModule>(param_stack.front().second);
}

std::list<std::pair<Parser::term_t,Parser::token_t>> Parser::Node::flatten(){
    std::list<std::pair<term_t,token_t>> results;
    for(Entry& child : children){
        if(std::holds_alternative<token_t>(child.elem)){
            results.emplace_back(child.term, std::get<token_t>(child.elem));
        }else{
            auto flattened = std::get<Node>(child.elem).flatten();
            results.insert(results.end(), flattened.begin(), flattened.end());
        }
    }
    return results;
}

WasmVM::ParseError::ParseError(Parser::term_t term){
    static const std::vector<std::string> terms {
        "",
        "EOF",
        "ParenL",
        "ParenR",
        "Id",
        "String",
        "Integer",
        "Float",
        "MemOffset",
        "MemAlign",
        "Module",
        "Type",
        "Import",
        "Export",
        "Param",
        "Result",
        "Funcref",
        "Extern",
        "Externref",
        "Func",
        "Table",
        "Memory",
        "Global",
        "Mut",
        "Local",
        "Elem",
        "Item",
        "Declare",
        "Offset",
        "Data",
        "Start",
        "Then",
        "Unreachable",
        "Block",
        "Nop",
        "End",
        "Loop",
        "If",
        "Else",
        "Br",
        "Br_if",
        "Br_table",
        "Return",
        "Call",
        "Call_indirect",
        "Ref_null",
        "Ref_is_null",
        "Ref_func",
        "Drop",
        "Select",
        "Local_get",
        "Local_set",
        "Local_tee",
        "Global_get",
        "Global_set",
        "Table_get",
        "Table_set",
        "Table_size",
        "Table_grow",
        "Table_fill",
        "Table_copy",
        "Table_init",
        "Elem_drop",
        "Memory_size",
        "Memory_grow",
        "Memory_fill",
        "Memory_init",
        "Memory_copy",
        "Data_drop",
        "I32_load",
        "I64_load",
        "F32_load",
        "F64_load",
        "I32_load8_s",
        "I32_load8_u",
        "I32_load16_s",
        "I32_load16_u",
        "I64_load8_s",
        "I64_load8_u",
        "I64_load16_s",
        "I64_load16_u",
        "I64_load32_s",
        "I64_load32_u",
        "I32_store",
        "I64_store",
        "F32_store",
        "F64_store",
        "I32_store8",
        "I32_store16",
        "I64_store8",
        "I64_store16",
        "I64_store32",
        "I32_const",
        "I64_const",
        "F32_const",
        "F64_const",
        "I32_eqz",
        "I32_eq",
        "I32_ne",
        "I32_lt_s",
        "I32_lt_u",
        "I32_gt_s",
        "I32_gt_u",
        "I32_le_s",
        "I32_le_u",
        "I32_ge_s",
        "I32_ge_u",
        "I64_eqz",
        "I64_eq",
        "I64_ne",
        "I64_lt_s",
        "I64_lt_u",
        "I64_gt_s",
        "I64_gt_u",
        "I64_le_s",
        "I64_le_u",
        "I64_ge_s",
        "I64_ge_u",
        "F32_eq",
        "F32_ne",
        "F32_lt",
        "F32_gt",
        "F32_le",
        "F32_ge",
        "F64_eq",
        "F64_ne",
        "F64_lt",
        "F64_gt",
        "F64_le",
        "F64_ge",
        "I32_clz",
        "I32_ctz",
        "I32_popcnt",
        "I32_add",
        "I32_sub",
        "I32_mul",
        "I32_div_s",
        "I32_div_u",
        "I32_rem_s",
        "I32_rem_u",
        "I32_and",
        "I32_or",
        "I32_xor",
        "I32_shl",
        "I32_shr_s",
        "I32_shr_u",
        "I32_rotl",
        "I32_rotr",
        "I64_clz",
        "I64_ctz",
        "I64_popcnt",
        "I64_add",
        "I64_sub",
        "I64_mul",
        "I64_div_s",
        "I64_div_u",
        "I64_rem_s",
        "I64_rem_u",
        "I64_and",
        "I64_or",
        "I64_xor",
        "I64_shl",
        "I64_shr_s",
        "I64_shr_u",
        "I64_rotl",
        "I64_rotr",
        "F32_abs",
        "F32_neg",
        "F32_ceil",
        "F32_floor",
        "F32_trunc",
        "F32_nearest",
        "F32_sqrt",
        "F32_add",
        "F32_sub",
        "F32_mul",
        "F32_div",
        "F32_min",
        "F32_max",
        "F32_copysign",
        "F64_abs",
        "F64_neg",
        "F64_ceil",
        "F64_floor",
        "F64_trunc",
        "F64_nearest",
        "F64_sqrt",
        "F64_add",
        "F64_sub",
        "F64_mul",
        "F64_div",
        "F64_min",
        "F64_max",
        "F64_copysign",
        "I32_wrap_i64",
        "I32_trunc_s_f32",
        "I32_trunc_u_f32",
        "I32_trunc_s_f64",
        "I32_trunc_u_f64",
        "I64_extend_s_i32",
        "I64_extend_u_i32",
        "I64_trunc_s_f32",
        "I64_trunc_u_f32",
        "I64_trunc_s_f64",
        "I64_trunc_u_f64",
        "F32_convert_s_i32",
        "F32_convert_u_i32",
        "F32_convert_s_i64",
        "F32_convert_u_i64",
        "F32_demote_f64",
        "F64_convert_s_i32",
        "F64_convert_u_i32",
        "F64_convert_s_i64",
        "F64_convert_u_i64",
        "F64_promote_f32",
        "I32_reinterpret_f32",
        "I64_reinterpret_f64",
        "F32_reinterpret_i32",
        "F64_reinterpret_i64",
        "I32_extend8_s",
        "I32_extend16_s",
        "I64_extend8_s",
        "I64_extend16_s",
        "I64_extend32_s",
        "I32_trunc_sat_f32_s",
        "I32_trunc_sat_f32_u",
        "I32_trunc_sat_f64_s",
        "I32_trunc_sat_f64_u",
        "I64_trunc_sat_f32_s",
        "I64_trunc_sat_f64_u",
        "I64_trunc_sat_f64_s",
        "I64_trunc_sat_f32_u",
        "NumType",
        "module",
    };
    msg = "unexpected " + terms[term];
}
} // namespace WasmVM


