/** generated by ParGen **/
#include "Parser.hpp"

#include <stack>
#include <list>
#include <variant>
#include <vector>
#include <algorithm>
#include <array>

namespace WasmVM {

using namespace Tokens;

Parser::Parser(Lexer& lexer) : lexer(lexer) {}

std::pair<Parser::term_t, Parser::token_t> Parser::fetch(){
    if(!buffer.empty()){
        auto token = buffer.front();
        buffer.pop_front();
        return token;
    }
    Token res = lexer.get();
    return {res.index() + 1, res};
}

static WasmModule action_1(Parser& _this, std::vector<Position> _pos, WasmModule _op0){
    return _op0;
}
static WasmModule action_2(Parser& _this, std::vector<Position> _pos, WasmModule _op0, WasmImport _op1){
    _op0.imports.emplace_back(_op1);
    return _op0;
}
static WasmModule action_3(Parser& _this, std::vector<Position> _pos, WasmModule _op0, std::variant<TableType, WasmImport> _op1){
    if(std::holds_alternative<WasmImport>(_op1)){
        _op0.imports.emplace_back(std::get<WasmImport>(_op1));
    }else{
        _op0.tables.emplace_back(std::get<TableType>(_op1));
    }
    return _op0;
}
static WasmModule action_4(Parser& _this, std::vector<Position> _pos, WasmModule _op0, std::variant<Limits, WasmImport> _op1){
    if(std::holds_alternative<WasmImport>(_op1)){
        _op0.imports.emplace_back(std::get<WasmImport>(_op1));
    }else{
        _op0.mems.emplace_back(std::get<Limits>(_op1));
    }
    return _op0;
}
static WasmModule action_5(Parser& _this, std::vector<Position> _pos, WasmModule _op0, std::variant<WasmGlobal, WasmImport> _op1){
    if(std::holds_alternative<WasmImport>(_op1)){
        _op0.imports.emplace_back(std::get<WasmImport>(_op1));
    }else{
        _op0.globals.emplace_back(std::get<WasmGlobal>(_op1));
    }
    return _op0;
}
static WasmModule action_6(Parser& _this, std::vector<Position> _pos){
    return WasmModule();
}
static WasmModule action_7(Parser& _this, std::vector<Position> _pos, Tokens::ParenL _op0, Tokens::Module _op1, Tokens::Id _op2, WasmModule _op3, Tokens::ParenR _op4){
    for(auto& functype : _this.types){
        _op3.types.emplace_back(functype.first);
    }
    _this.reset();
    return _op3;
}
static WasmModule action_8(Parser& _this, std::vector<Position> _pos, Tokens::ParenL _op0, Tokens::Module _op1, WasmModule _op2, Tokens::ParenR _op3){
    for(auto& functype : _this.types){
        _op2.types.emplace_back(functype.first);
    }
    _this.reset();
    return _op2;
}
static WasmModule action_9(Parser& _this, std::vector<Position> _pos, WasmModule _op0){
    for(auto& functype : _this.types){
        _op0.types.emplace_back(functype.first);
    }
    _this.reset();
    return _op0;
}
static WasmModule action_10(Parser& _this, std::vector<Position> _pos, Tokens::ParenL _op0, Tokens::ParenR _op1){
    _this.reset();
    return WasmModule();
}
static WasmModule action_11(Parser& _this, std::vector<Position> _pos){
    _this.reset();
    return WasmModule();
}
static ValueType action_12(Parser& _this, std::vector<Position> _pos, Tokens::NumType _op0){
    if(_op0.value == "i32"){
        return ValueType::i32;
    }else if(_op0.value == "i64"){
        return ValueType::i64;
    }else if(_op0.value == "f32"){
        return ValueType::f32;
    }else{
        return ValueType::f64;
    }
}
static ValueType action_13(Parser& _this, std::vector<Position> _pos, Tokens::Funcref _op0){
    return ValueType::funcref;
}
static ValueType action_14(Parser& _this, std::vector<Position> _pos, Tokens::Externref _op0){
    return ValueType::externref;
}
static RefType action_15(Parser& _this, std::vector<Position> _pos, Tokens::Funcref _op0){
    return RefType::funcref;
}
static RefType action_16(Parser& _this, std::vector<Position> _pos, Tokens::Externref _op0){
    return RefType::externref;
}
static std::vector<ValueType> action_17(Parser& _this, std::vector<Position> _pos, std::vector<ValueType> _op0, ValueType _op1){
    _op0.emplace_back(_op1);
    return _op0;
}
static std::vector<ValueType> action_18(Parser& _this, std::vector<Position> _pos){
    return std::vector<ValueType>();
}
static std::pair<std::vector<ValueType>, std::map<std::string, index_t>> action_19(Parser& _this, std::vector<Position> _pos, std::pair<std::vector<ValueType>, std::map<std::string, index_t>> _op0, Tokens::ParenL _op1, Tokens::Param _op2, Tokens::Id _op3, ValueType _op4, Tokens::ParenR _op5){
    if(_op0.second.contains(_op3.value)){
        throw Exception::Parse("parameter ID '" + _op3.value + "' is duplicated", {_pos[3].line, _pos[3].column});
    }
    _op0.second.emplace(_op3.value, _op0.first.size());
    _op0.first.emplace_back(_op4);
    return _op0;
}
static std::pair<std::vector<ValueType>, std::map<std::string, index_t>> action_20(Parser& _this, std::vector<Position> _pos, std::pair<std::vector<ValueType>, std::map<std::string, index_t>> _op0, Tokens::ParenL _op1, Tokens::Param _op2, std::vector<ValueType> _op3, Tokens::ParenR _op4){
    _op0.first.insert(_op0.first.end(), _op3.begin(), _op3.end());
    return _op0;
}
static std::pair<std::vector<ValueType>, std::map<std::string, index_t>> action_21(Parser& _this, std::vector<Position> _pos){
    return std::pair<std::vector<ValueType>, std::map<std::string, index_t>>();
}
static std::vector<ValueType> action_22(Parser& _this, std::vector<Position> _pos, std::vector<ValueType> _op0, Tokens::ParenL _op1, Tokens::Result _op2, std::vector<ValueType> _op3, Tokens::ParenR _op4){
    _op0.insert(_op0.end(), _op3.begin(), _op3.end());
    return _op0;
}
static std::vector<ValueType> action_23(Parser& _this, std::vector<Position> _pos){
    return std::vector<ValueType>();
}
static std::pair<FuncType, std::map<std::string, index_t>> action_24(Parser& _this, std::vector<Position> _pos, Tokens::ParenL _op0, Tokens::Func _op1, std::pair<std::vector<ValueType>, std::map<std::string, index_t>> _op2, std::vector<ValueType> _op3, Tokens::ParenR _op4){
    return {FuncType {.params = _op2.first, .results = _op3}, _op2.second};
}
static RefType action_25(Parser& _this, std::vector<Position> _pos, Tokens::Func _op0){
    return RefType::funcref;
}
static RefType action_26(Parser& _this, std::vector<Position> _pos, Tokens::Extern _op0){
    return RefType::externref;
}
static std::string action_27(Parser& _this, std::vector<Position> _pos, Tokens::Id _op0){
    return _op0.value;
}
static std::string action_28(Parser& _this, std::vector<Position> _pos){
    return "";
}
static void action_29(Parser& _this, std::vector<Position> _pos, Tokens::ParenL _op0, Tokens::Type _op1, std::string _op2, std::pair<FuncType, std::map<std::string, index_t>> _op3, Tokens::ParenR _op4){
    if(!_op2.empty()){
        if(_this.type_indices.contains(_op2)){
            throw Exception::Parse("type ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
        }
        _this.type_indices[_op2] = _this.types.size();
    }
    _this.types.emplace_back(_op3);
}
static u32_t action_30(Parser& _this, std::vector<Position> _pos, Tokens::Integer _op0){
    try{
        return std::stoul(_op0.value, 0);
    }catch(std::invalid_argument){
        throw Exception::Parse("invalid u32 integer '" + _op0.value + "'", {_pos[0].line, _pos[0].column});
    }
}
static i32_t action_31(Parser& _this, std::vector<Position> _pos, Tokens::Integer _op0){
    try{
        return std::stol(_op0.value, 0);
    }catch(std::invalid_argument){
        throw Exception::Parse("invalid i32 integer '" + _op0.value + "'", {_pos[0].line, _pos[0].column});
    }
}
static i64_t action_32(Parser& _this, std::vector<Position> _pos, Tokens::Integer _op0){
    try{
        return std::stoll(_op0.value, 0);
    }catch(std::invalid_argument){
        throw Exception::Parse("invalid i64 integer '" + _op0.value + "'", {_pos[0].line, _pos[0].column});
    }
}
static f32_t action_33(Parser& _this, std::vector<Position> _pos, Tokens::Float _op0){
    try{
        auto nanpos = _op0.value.find("nan:0x");
        if(nanpos != std::string::npos){
            u32_t nan_imm = 0x7f800000UL + std::stoul(_op0.value.substr(nanpos + 4), nullptr, 16);
            if(_op0.value.starts_with("-")){
                nan_imm += 0x80000000UL;
            }
            return *reinterpret_cast<f32_t*>(&nan_imm);
        }else{
            return std::stof(_op0.value);
        }
    }catch(std::invalid_argument){
        throw Exception::Parse("invalid f32 number '" + _op0.value + "'", {_pos[0].line, _pos[0].column});
    }
}
static f64_t action_34(Parser& _this, std::vector<Position> _pos, Tokens::Float _op0){
    try{
        auto nanpos = _op0.value.find("nan:0x");
        if(nanpos != std::string::npos){
            u64_t nan_imm = 0x7ff0000000000000ULL + std::stoull(_op0.value.substr(nanpos + 4), nullptr, 16);
            if(_op0.value.starts_with("-")){
                nan_imm += 0x8000000000000000ULL;
            }
            return *reinterpret_cast<f64_t*>(&nan_imm);
        }else{
            return std::stod(_op0.value);
        }
    }catch(std::invalid_argument){
        throw Exception::Parse("invalid f64 number '" + _op0.value + "'", {_pos[0].line, _pos[0].column});
    }
}
static u32_t action_35(Parser& _this, std::vector<Position> _pos, u32_t _op0){
    return _op0;
}
static u32_t action_36(Parser& _this, std::vector<Position> _pos, Tokens::Id _op0){
    if(!_this.type_indices.contains(_op0.value)){
        throw Exception::Parse("type ID '" + _op0.value + "' not found", {_pos[0].line, _pos[0].column});
    }
    return _this.type_indices[_op0.value];
}
static u32_t action_37(Parser& _this, std::vector<Position> _pos, u32_t _op0){
    return _op0;
}
static u32_t action_38(Parser& _this, std::vector<Position> _pos, Tokens::Id _op0){
    index_t index = _this.func_indices.get(_op0.value);
    if(index == -1){
        throw Exception::Parse("function ID '" + _op0.value + "' not found", {_pos[0].line, _pos[0].column});
    }
    return index;
}
static u32_t action_39(Parser& _this, std::vector<Position> _pos, u32_t _op0){
    return _op0;
}
static u32_t action_40(Parser& _this, std::vector<Position> _pos, Tokens::Id _op0){
    index_t index = _this.table_indices.get(_op0.value);
    if(index == -1){
        throw Exception::Parse("table ID '" + _op0.value + "' not found", {_pos[0].line, _pos[0].column});
    }
    return index;
}
static u32_t action_41(Parser& _this, std::vector<Position> _pos, u32_t _op0){
    return _op0;
}
static u32_t action_42(Parser& _this, std::vector<Position> _pos, Tokens::Id _op0){
    index_t index = _this.mem_indices.get(_op0.value);
    if(index == -1){
        throw Exception::Parse("memory ID '" + _op0.value + "' not found", {_pos[0].line, _pos[0].column});
    }
    return index;
}
static u32_t action_43(Parser& _this, std::vector<Position> _pos, u32_t _op0){
    return _op0;
}
static u32_t action_44(Parser& _this, std::vector<Position> _pos, Tokens::Id _op0){
    index_t index = _this.global_indices.get(_op0.value);
    if(index == -1){
        throw Exception::Parse("global ID '" + _op0.value + "' not found", {_pos[0].line, _pos[0].column});
    }
    return index;
}
static u32_t action_45(Parser& _this, std::vector<Position> _pos, Tokens::ParenL _op0, Tokens::Type _op1, u32_t _op2, Tokens::ParenR _op3, std::pair<std::vector<ValueType>, std::map<std::string, index_t>> _op4, std::vector<ValueType> _op5){
    if(_op4.first.empty() && _op5.empty()){
        return _op2;
    }
    std::pair<FuncType, std::map<std::string, index_t>> derived = _this.types[_op2];
    for(auto& id_pair : _op4.second){
        if(derived.second.contains(id_pair.first)){
            throw Exception::Parse("parameter ID '" + id_pair.first + "' is duplicated", {_pos[4].line, _pos[4].column});
        }
        derived.second[id_pair.first] = id_pair.second + derived.first.params.size();
    }
    derived.first.params.insert(derived.first.params.end(), _op4.first.begin(), _op4.first.end());
    derived.first.results.insert(derived.first.results.end(), _op5.begin(), _op5.end());
    index_t index = _this.types.size();
    _this.types.emplace_back(derived);
    return index;
}
static u32_t action_46(Parser& _this, std::vector<Position> _pos, std::pair<std::vector<ValueType>, std::map<std::string, index_t>> _op0, std::vector<ValueType> _op1){
    index_t index = _this.types.size();
    _this.types.emplace_back(FuncType {.params = _op0.first, .results = _op1}, _op0.second);
    return index;
}
static u32_t action_47(Parser& _this, std::vector<Position> _pos){
    index_t index = _this.types.size();
    _this.types.emplace_back(FuncType(), std::map<std::string, index_t>());
    return index;
}
static Limits action_48(Parser& _this, std::vector<Position> _pos, u32_t _op0){
    return Limits {.min = _op0};
}
static Limits action_49(Parser& _this, std::vector<Position> _pos, u32_t _op0, u32_t _op1){
    return Limits {.min = _op0, .max = _op1};
}
static TableType action_50(Parser& _this, std::vector<Position> _pos, Limits _op0, RefType _op1){
    return TableType {.limits = _op0, .reftype = _op1};
}
static GlobalType action_51(Parser& _this, std::vector<Position> _pos, ValueType _op0){
    return GlobalType {.mut = GlobalType::constant, .type = _op0};
}
static GlobalType action_52(Parser& _this, std::vector<Position> _pos, Tokens::ParenL _op0, Tokens::Mut _op1, ValueType _op2, Tokens::ParenR _op3){
    return GlobalType {.mut = GlobalType::variable, .type = _op2};
}
static ConstInstr action_53(Parser& _this, std::vector<Position> _pos, Tokens::Ref_null _op0, RefType _op1){
    return Instr::Ref_null(_op1);
}
static ConstInstr action_54(Parser& _this, std::vector<Position> _pos, Tokens::Ref_func _op0, u32_t _op1){
    return Instr::Ref_func(_op1);
}
static ConstInstr action_55(Parser& _this, std::vector<Position> _pos, Tokens::I32_const _op0, i32_t _op1){
    return Instr::I32_const(_op1);
}
static ConstInstr action_56(Parser& _this, std::vector<Position> _pos, Tokens::I64_const _op0, i64_t _op1){
    return Instr::I64_const(_op1);
}
static ConstInstr action_57(Parser& _this, std::vector<Position> _pos, Tokens::F32_const _op0, f32_t _op1){
    return Instr::F32_const(_op1);
}
static ConstInstr action_58(Parser& _this, std::vector<Position> _pos, Tokens::F64_const _op0, f64_t _op1){
    return Instr::F64_const(_op1);
}
static ConstInstr action_59(Parser& _this, std::vector<Position> _pos, Tokens::VariableInstr _op0, u32_t _op1){
    if(_op0.value != VariableInstr::GlobalGet){
        throw Exception::Parse("invalid expr in global init ", {_pos[0].line, _pos[0].column});
    }
    return Instr::Global_get(_op1);
}
static WasmImport action_60(Parser& _this, std::vector<Position> _pos, Tokens::ParenL _op0, Tokens::Import _op1, Tokens::String _op2, Tokens::String _op3, std::variant<index_t, TableType, MemType, GlobalType> _op4, Tokens::ParenR _op5){
    return WasmImport {.module = _op2.value, .name = _op3.value, .desc = _op4};
}
static std::variant<index_t, TableType, MemType, GlobalType> action_61(Parser& _this, std::vector<Position> _pos, Tokens::ParenL _op0, Tokens::Func _op1, std::string _op2, u32_t _op3, Tokens::ParenR _op4){
    if(!_op2.empty()){
        if(_this.func_indices.contains(_op2)){
            throw Exception::Parse("function ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
        }
        _this.func_indices.insert(_op2, Parser::IndexMap::Import);
    }else{
        _this.func_indices.insert(Parser::IndexMap::Import);
    }
    return _op3;
}
static std::variant<index_t, TableType, MemType, GlobalType> action_62(Parser& _this, std::vector<Position> _pos, Tokens::ParenL _op0, Tokens::Table _op1, std::string _op2, TableType _op3, Tokens::ParenR _op4){
    if(!_op2.empty()){
        if(_this.table_indices.contains(_op2)){
            throw Exception::Parse("table ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
        }
        _this.table_indices.insert(_op2, Parser::IndexMap::Import);
    }else{
        _this.table_indices.insert(Parser::IndexMap::Import);
    }
    return _op3;
}
static std::variant<index_t, TableType, MemType, GlobalType> action_63(Parser& _this, std::vector<Position> _pos, Tokens::ParenL _op0, Tokens::Memory _op1, std::string _op2, Limits _op3, Tokens::ParenR _op4){
    if(!_op2.empty()){
        if(_this.mem_indices.contains(_op2)){
            throw Exception::Parse("memory ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
        }
        _this.mem_indices.insert(_op2, Parser::IndexMap::Import);
    }else{
        _this.mem_indices.insert(Parser::IndexMap::Import);
    }
    return _op3;
}
static std::variant<index_t, TableType, MemType, GlobalType> action_64(Parser& _this, std::vector<Position> _pos, Tokens::ParenL _op0, Tokens::Global _op1, std::string _op2, GlobalType _op3, Tokens::ParenR _op4){
    if(!_op2.empty()){
        if(_this.global_indices.contains(_op2)){
            throw Exception::Parse("global ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
        }
        _this.global_indices.insert(_op2, Parser::IndexMap::Import);
    }else{
        _this.global_indices.insert(Parser::IndexMap::Import);
    }
    return _op3;
}
static std::variant<TableType, WasmImport> action_65(Parser& _this, std::vector<Position> _pos, Tokens::ParenL _op0, Tokens::Table _op1, std::string _op2, TableType _op3, Tokens::ParenR _op4){
    if(!_op2.empty()){
        if(_this.table_indices.contains(_op2)){
            throw Exception::Parse("table ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
        }
        _this.table_indices.insert(_op2, Parser::IndexMap::Normal);
    }else{
        _this.table_indices.insert(Parser::IndexMap::Normal);
    }
    return _op3;
}
static std::variant<TableType, WasmImport> action_66(Parser& _this, std::vector<Position> _pos, Tokens::ParenL _op0, Tokens::Table _op1, std::string _op2, Tokens::ParenL _op3, Tokens::Import _op4, Tokens::String _op5, Tokens::String _op6, Tokens::ParenR _op7, TableType _op8, Tokens::ParenR _op9){
    if(!_op2.empty()){
        if(_this.table_indices.contains(_op2)){
            throw Exception::Parse("table ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
        }
        _this.table_indices.insert(_op2, Parser::IndexMap::Import);
    }else{
        _this.table_indices.insert(Parser::IndexMap::Import);
    }
    return WasmImport {.module = _op5.value, .name = _op6.value, .desc = _op8};
}
static std::variant<Limits, WasmImport> action_67(Parser& _this, std::vector<Position> _pos, Tokens::ParenL _op0, Tokens::Memory _op1, std::string _op2, Limits _op3, Tokens::ParenR _op4){
    if(!_op2.empty()){
        if(_this.mem_indices.contains(_op2)){
            throw Exception::Parse("memory ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
        }
        _this.mem_indices.insert(_op2, Parser::IndexMap::Normal);
    }else{
        _this.mem_indices.insert(Parser::IndexMap::Normal);
    }
    return _op3;
}
static std::variant<Limits, WasmImport> action_68(Parser& _this, std::vector<Position> _pos, Tokens::ParenL _op0, Tokens::Memory _op1, std::string _op2, Tokens::ParenL _op3, Tokens::Import _op4, Tokens::String _op5, Tokens::String _op6, Tokens::ParenR _op7, Limits _op8, Tokens::ParenR _op9){
    if(!_op2.empty()){
        if(_this.mem_indices.contains(_op2)){
            throw Exception::Parse("memory ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
        }
        _this.mem_indices.insert(_op2, Parser::IndexMap::Import);
    }else{
        _this.mem_indices.insert(Parser::IndexMap::Import);
    }
    return WasmImport {.module = _op5.value, .name = _op6.value, .desc = _op8};
}
static std::variant<WasmGlobal, WasmImport> action_69(Parser& _this, std::vector<Position> _pos, Tokens::ParenL _op0, Tokens::Global _op1, std::string _op2, GlobalType _op3, ConstInstr _op4, Tokens::ParenR _op5){
    if(!_op2.empty()){
        if(_this.global_indices.contains(_op2)){
            throw Exception::Parse("global ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
        }
        _this.global_indices.insert(_op2, Parser::IndexMap::Normal);
    }else{
        _this.global_indices.insert(Parser::IndexMap::Normal);
    }
    return WasmGlobal {.type = _op3, .init = _op4};
}
static std::variant<WasmGlobal, WasmImport> action_70(Parser& _this, std::vector<Position> _pos, Tokens::ParenL _op0, Tokens::Global _op1, std::string _op2, Tokens::ParenL _op3, Tokens::Import _op4, Tokens::String _op5, Tokens::String _op6, Tokens::ParenR _op7, GlobalType _op8, Tokens::ParenR _op9){
    if(!_op2.empty()){
        if(_this.global_indices.contains(_op2)){
            throw Exception::Parse("global ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
        }
        _this.global_indices.insert(_op2, Parser::IndexMap::Import);
    }else{
        _this.global_indices.insert(Parser::IndexMap::Import);
    }
    return WasmImport {.module = _op5.value, .name = _op6.value, .desc = _op8};
}

std::vector<Parser::State> Parser::table = {
    {{1, {{3,{}},}},{2, {{5,{}},}},{71, {{33,{}},}},{78, {{35,{}},}},{82, {{37,{}},}},{83, {{7,{}},}},{84, {{9,{}},}},{88, {{41,{}},}},{91, {{43,{}},}},},
    {{1, {{22,{1,}},}},},
    {{3, {{11,{}},}},{10, {{13,{}},}},{11, {{57,{}},}},{12, {{59,{}},}},{20, {{61,{}},}},{21, {{63,{}},}},{22, {{65,{}},}},},
    {{1, {{0,{}},}},},
    {{1, {{18,{1,}},}},{2, {{5,{}},}},{71, {{15,{}},}},{78, {{17,{}},}},{82, {{19,{}},}},{88, {{21,{}},}},{91, {{23,{}},}},},
    {{1, {{20,{1,1,}},}},},
    {{2, {{5,{}},}},{3, {{25,{}},}},{4, {{27,{}},}},{71, {{33,{}},}},{78, {{35,{}},}},{82, {{37,{}},}},{84, {{29,{}},}},{88, {{41,{}},}},{91, {{43,{}},}},},
    {{1, {{10,{1,1,}},}},{2, {{10,{1,1,}},}},{3, {{10,{1,1,}},}},},
    {{1, {{4,{1,1,}},}},{2, {{4,{1,1,}},}},{3, {{4,{1,1,}},}},},
    {{1, {{8,{1,1,}},}},{2, {{8,{1,1,}},}},{3, {{8,{1,1,}},}},},
    {{1, {{6,{1,1,}},}},{2, {{6,{1,1,}},}},{3, {{6,{1,1,}},}},},
    {{1, {{2,{1,1,}},}},{2, {{2,{1,1,}},}},{3, {{2,{1,1,}},}},},
    {{1, {{16,{1,1,0,1,}},}},},
    {{2, {{5,{}},}},{3, {{31,{}},}},{71, {{33,{}},}},{78, {{35,{}},}},{82, {{37,{}},}},{84, {{39,{}},}},{88, {{41,{}},}},{91, {{43,{}},}},},
    {{2, {{5,{}},}},{3, {{45,{}},}},{71, {{15,{}},}},{78, {{17,{}},}},{82, {{19,{}},}},{88, {{21,{}},}},{91, {{23,{}},}},},
    {{1, {{14,{1,1,1,0,1,}},}},},
    {{1, {{10,{0,1,}},}},{2, {{10,{0,1,}},}},{3, {{10,{0,1,}},}},},
    {{1, {{4,{0,1,}},}},{2, {{4,{0,1,}},}},{3, {{4,{0,1,}},}},},
    {{1, {{8,{0,1,}},}},{2, {{8,{0,1,}},}},{3, {{8,{0,1,}},}},},
    {{2, {{5,{}},}},{3, {{55,{}},}},{71, {{15,{}},}},{78, {{17,{}},}},{82, {{19,{}},}},{88, {{21,{}},}},{91, {{23,{}},}},},
    {{1, {{6,{0,1,}},}},{2, {{6,{0,1,}},}},{3, {{6,{0,1,}},}},},
    {{1, {{2,{0,1,}},}},{2, {{2,{0,1,}},}},{3, {{2,{0,1,}},}},},
    {{1, {{16,{1,1,1,1,}},}},},
    {{2, {{271,{}},}},{3, {{67,{}},}},{85, {{69,{}},}},{87, {{71,{}},}},},
    {{3, {{100,{1,1,}},}},},
    {{3, {{98,{1,1,}},}},{16, {{98,{1,1,}},}},{18, {{98,{1,1,}},}},},
    {{16, {{397,{}},}},{18, {{399,{}},}},{65, {{401,{}},}},{95, {{73,{}},}},},
    {{1, {{14,{1,1,1,1,1,}},}},},
    {{2, {{139,{}},}},{4, {{203,{}},}},{70, {{89,{}},}},{77, {{91,{}},}},},
    {{5, {{93,{}},}},},
    {{2, {{95,{}},}},{4, {{203,{}},}},{6, {{417,{}},}},{77, {{97,{}},}},{80, {{385,{}},}},{90, {{99,{}},}},{94, {{393,{}},}},},
    {{2, {{101,{}},}},{4, {{203,{}},}},{6, {{417,{}},}},{77, {{103,{}},}},{80, {{105,{}},}},{94, {{393,{}},}},},
    {{2, {{107,{}},}},{4, {{203,{}},}},{16, {{397,{}},}},{18, {{399,{}},}},{65, {{401,{}},}},{73, {{109,{}},}},{77, {{111,{}},}},{95, {{405,{}},}},},
    {{3, {{48,{1,1,0,0,1,}},}},},
    {{2, {{117,{}},}},{3, {{119,{}},}},{87, {{121,{}},}},},
    {{2, {{123,{}},}},{3, {{125,{}},}},},
    {{3, {{135,{}},}},},
    {{3, {{106,{1,1,}},}},},
    {{3, {{108,{1,1,}},}},},
    {{3, {{118,{1,1,}},}},},
    {{3, {{110,{1,1,}},}},},
    {{3, {{112,{1,1,}},}},},
    {{3, {{114,{1,1,}},}},},
    {{3, {{116,{1,1,}},}},},
    {{3, {{137,{}},}},},
    {{2, {{139,{}},}},{70, {{141,{}},}},},
    {{5, {{143,{}},}},},
    {{12, {{145,{}},}},},
    {{2, {{147,{}},}},{6, {{417,{}},}},{80, {{385,{}},}},{90, {{149,{}},}},{94, {{393,{}},}},},
    {{3, {{151,{}},}},},
    {{12, {{153,{}},}},},
    {{2, {{155,{}},}},{6, {{417,{}},}},{80, {{157,{}},}},{94, {{393,{}},}},},
    {{3, {{159,{}},}},},
    {{12, {{161,{}},}},{23, {{53,{}},}},},
    {{43, {{233,{}},}},{45, {{235,{}},}},{48, {{237,{}},}},{60, {{239,{}},}},{61, {{241,{}},}},{62, {{243,{}},}},{63, {{245,{}},}},{66, {{163,{}},}},},
    {{2, {{165,{}},}},{16, {{397,{}},}},{18, {{399,{}},}},{65, {{401,{}},}},{73, {{167,{}},}},{95, {{405,{}},}},},
    {{3, {{169,{}},}},{4, {{171,{}},}},{16, {{397,{}},}},{18, {{399,{}},}},{65, {{401,{}},}},{95, {{265,{}},}},{96, {{173,{}},}},},
    {{3, {{175,{}},}},{16, {{397,{}},}},{18, {{399,{}},}},{65, {{401,{}},}},{95, {{265,{}},}},{96, {{177,{}},}},},
    {{14, {{179,{}},}},{15, {{115,{}},}},},
    {{3, {{48,{1,1,1,0,1,}},}},},
    {{2, {{123,{}},}},{3, {{181,{}},}},},
    {{15, {{183,{}},}},},
    {{3, {{48,{1,1,0,1,1,}},}},},
    {{2, {{271,{}},}},{3, {{185,{}},}},{4, {{203,{}},}},{77, {{187,{}},}},{85, {{189,{}},}},{87, {{191,{}},}},{93, {{193,{}},}},},
    {{4, {{203,{}},}},{6, {{417,{}},}},{77, {{195,{}},}},{80, {{385,{}},}},{90, {{197,{}},}},{94, {{393,{}},}},},
    {{4, {{203,{}},}},{6, {{417,{}},}},{77, {{199,{}},}},{80, {{201,{}},}},{94, {{393,{}},}},},
    {{2, {{107,{}},}},{4, {{203,{}},}},{16, {{397,{}},}},{18, {{399,{}},}},{65, {{401,{}},}},{73, {{205,{}},}},{77, {{207,{}},}},{95, {{405,{}},}},},
    {{3, {{104,{1,1,1,1,}},}},{43, {{104,{1,1,1,1,}},}},{45, {{104,{1,1,1,1,}},}},{48, {{104,{1,1,1,1,}},}},{60, {{104,{1,1,1,1,}},}},{61, {{104,{1,1,1,1,}},}},{62, {{104,{1,1,1,1,}},}},{63, {{104,{1,1,1,1,}},}},},
    {{1, {{58,{1,1,0,1,1,}},}},{2, {{58,{1,1,0,1,1,}},}},{3, {{58,{1,1,0,1,1,}},}},},
    {{19, {{47,{}},}},},
    {{3, {{209,{}},}},},
    {{2, {{211,{}},}},{79, {{213,{}},}},},
    {{5, {{215,{}},}},},
    {{12, {{217,{}},}},},
    {{3, {{219,{}},}},},
    {{1, {{130,{1,1,0,1,1,}},}},{2, {{130,{1,1,0,1,1,}},}},{3, {{130,{1,1,0,1,1,}},}},},
    {{5, {{221,{}},}},},
    {{12, {{223,{}},}},},
    {{3, {{225,{}},}},},
    {{1, {{134,{1,1,0,1,1,}},}},{2, {{134,{1,1,0,1,1,}},}},{3, {{134,{1,1,0,1,1,}},}},},
    {{5, {{227,{}},}},},
    {{3, {{229,{}},}},},
    {{12, {{231,{}},}},{23, {{53,{}},}},},
    {{43, {{233,{}},}},{45, {{235,{}},}},{48, {{237,{}},}},{60, {{239,{}},}},{61, {{241,{}},}},{62, {{243,{}},}},{63, {{245,{}},}},{66, {{247,{}},}},},
    {{2, {{40,{0,1,1,0,1,}},}},{3, {{40,{0,1,1,0,1,}},}},},
    {{16, {{397,{}},}},{18, {{399,{}},}},{65, {{401,{}},}},{95, {{249,{}},}},},
    {{3, {{251,{}},}},{16, {{397,{}},}},{18, {{399,{}},}},{65, {{401,{}},}},{95, {{253,{}},}},},
    {{2, {{44,{0,1,1,0,1,}},}},{3, {{44,{0,1,1,0,1,}},}},},
    {{3, {{255,{}},}},{16, {{397,{}},}},{18, {{399,{}},}},{65, {{401,{}},}},{95, {{253,{}},}},},
    {{3, {{257,{}},}},{4, {{259,{}},}},{16, {{397,{}},}},{18, {{399,{}},}},{65, {{401,{}},}},{95, {{265,{}},}},{96, {{261,{}},}},},
    {{3, {{48,{1,1,1,1,1,}},}},},
    {{3, {{263,{}},}},{16, {{397,{}},}},{18, {{399,{}},}},{65, {{401,{}},}},{95, {{265,{}},}},{96, {{267,{}},}},},
    {{3, {{122,{1,1,0,0,1,}},}},},
    {{2, {{271,{}},}},{3, {{273,{}},}},{85, {{189,{}},}},{87, {{191,{}},}},{93, {{275,{}},}},},
    {{2, {{117,{}},}},{3, {{92,{1,0,}},}},{87, {{277,{}},}},},
    {{2, {{123,{}},}},{3, {{92,{0,1,}},}},},
    {{3, {{279,{}},}},},
    {{6, {{417,{}},}},{80, {{385,{}},}},{90, {{281,{}},}},{94, {{393,{}},}},},
    {{3, {{283,{}},}},},
    {{6, {{417,{}},}},{80, {{285,{}},}},{94, {{393,{}},}},},
    {{3, {{287,{}},}},},
    {{2, {{54,{1,}},}},{3, {{54,{1,}},}},{6, {{54,{1,}},}},{16, {{54,{1,}},}},{18, {{54,{1,}},}},{65, {{54,{1,}},}},},
    {{3, {{289,{}},}},},
    {{2, {{107,{}},}},{16, {{397,{}},}},{18, {{399,{}},}},{65, {{401,{}},}},{73, {{291,{}},}},{95, {{405,{}},}},},
    {{1, {{58,{1,1,1,1,1,}},}},{2, {{58,{1,1,1,1,1,}},}},{3, {{58,{1,1,1,1,1,}},}},},
    {{19, {{127,{}},}},{20, {{129,{}},}},{21, {{131,{}},}},{22, {{133,{}},}},},
    {{3, {{293,{}},}},},
    {{5, {{295,{}},}},},
    {{5, {{297,{}},}},},
    {{1, {{130,{1,1,1,1,1,}},}},{2, {{130,{1,1,1,1,1,}},}},{3, {{130,{1,1,1,1,1,}},}},},
    {{5, {{299,{}},}},},
    {{5, {{301,{}},}},},
    {{1, {{134,{1,1,1,1,1,}},}},{2, {{134,{1,1,1,1,1,}},}},{3, {{134,{1,1,1,1,1,}},}},},
    {{5, {{303,{}},}},},
    {{1, {{138,{1,1,0,1,1,1,}},}},{2, {{138,{1,1,0,1,1,1,}},}},{3, {{138,{1,1,0,1,1,1,}},}},},
    {{5, {{305,{}},}},},
    {{17, {{307,{}},}},{19, {{309,{}},}},{74, {{75,{}},}},},
    {{4, {{311,{}},}},{6, {{417,{}},}},{69, {{77,{}},}},{94, {{313,{}},}},},
    {{4, {{315,{}},}},{6, {{417,{}},}},{72, {{79,{}},}},{94, {{317,{}},}},},
    {{6, {{319,{}},}},{75, {{81,{}},}},},
    {{6, {{321,{}},}},{76, {{83,{}},}},},
    {{7, {{323,{}},}},{67, {{85,{}},}},},
    {{7, {{325,{}},}},{68, {{87,{}},}},},
    {{3, {{327,{}},}},},
    {{3, {{329,{}},}},},
    {{2, {{40,{0,1,1,1,1,}},}},{3, {{40,{0,1,1,1,1,}},}},},
    {{3, {{34,{1,1,}},}},{16, {{34,{1,1,}},}},{18, {{34,{1,1,}},}},{65, {{34,{1,1,}},}},},
    {{2, {{44,{0,1,1,1,1,}},}},{3, {{44,{0,1,1,1,1,}},}},},
    {{2, {{40,{1,1,1,0,1,}},}},{3, {{40,{1,1,1,0,1,}},}},},
    {{16, {{397,{}},}},{18, {{399,{}},}},{65, {{401,{}},}},{95, {{331,{}},}},},
    {{3, {{333,{}},}},{16, {{397,{}},}},{18, {{399,{}},}},{65, {{401,{}},}},{95, {{253,{}},}},},
    {{2, {{44,{1,1,1,0,1,}},}},{3, {{44,{1,1,1,0,1,}},}},},
    {{3, {{34,{0,1,}},}},{16, {{34,{0,1,}},}},{18, {{34,{0,1,}},}},{65, {{34,{0,1,}},}},},
    {{3, {{335,{}},}},{16, {{397,{}},}},{18, {{399,{}},}},{65, {{401,{}},}},{95, {{253,{}},}},},
    {{4, {{337,{}},}},{6, {{417,{}},}},{92, {{339,{}},}},{94, {{341,{}},}},},
    {{11, {{269,{}},}},{14, {{113,{}},}},{15, {{115,{}},}},},
    {{3, {{122,{1,1,1,0,1,}},}},},
    {{3, {{343,{}},}},},
    {{2, {{123,{}},}},{3, {{92,{1,1,}},}},},
    {{3, {{122,{1,1,0,1,1,}},}},},
    {{3, {{345,{}},}},},
    {{3, {{124,{1,1,0,1,1,}},}},},
    {{3, {{347,{}},}},},
    {{3, {{126,{1,1,0,1,1,}},}},},
    {{3, {{128,{1,1,0,1,1,}},}},},
    {{3, {{349,{}},}},},
    {{1, {{120,{1,1,1,1,1,1,}},}},{2, {{120,{1,1,1,1,1,1,}},}},{3, {{120,{1,1,1,1,1,1,}},}},},
    {{3, {{351,{}},}},},
    {{5, {{353,{}},}},},
    {{3, {{355,{}},}},},
    {{5, {{357,{}},}},},
    {{3, {{359,{}},}},},
    {{5, {{361,{}},}},},
    {{3, {{52,{1,}},}},},
    {{3, {{50,{1,}},}},},
    {{3, {{76,{1,}},}},},
    {{3, {{74,{1,}},}},},
    {{3, {{88,{1,}},}},},
    {{3, {{86,{1,}},}},},
    {{3, {{62,{1,}},}},},
    {{3, {{64,{1,}},}},},
    {{3, {{66,{1,}},}},},
    {{3, {{68,{1,}},}},},
    {{1, {{138,{1,1,1,1,1,1,}},}},{2, {{138,{1,1,1,1,1,1,}},}},{3, {{138,{1,1,1,1,1,1,}},}},},
    {{2, {{38,{0,1,1,1,1,1,}},}},{3, {{38,{0,1,1,1,1,1,}},}},},
    {{3, {{363,{}},}},},
    {{2, {{40,{1,1,1,1,1,}},}},{3, {{40,{1,1,1,1,1,}},}},},
    {{2, {{44,{1,1,1,1,1,}},}},{3, {{44,{1,1,1,1,1,}},}},},
    {{3, {{72,{1,}},}},},
    {{3, {{365,{}},}},},
    {{3, {{70,{1,}},}},},
    {{3, {{122,{1,1,1,1,1,}},}},},
    {{3, {{124,{1,1,1,1,1,}},}},},
    {{3, {{126,{1,1,1,1,1,}},}},},
    {{3, {{128,{1,1,1,1,1,}},}},},
    {{6, {{417,{}},}},{80, {{385,{}},}},{90, {{367,{}},}},{94, {{393,{}},}},},
    {{3, {{369,{}},}},},
    {{6, {{417,{}},}},{80, {{371,{}},}},{94, {{393,{}},}},},
    {{3, {{373,{}},}},},
    {{2, {{107,{}},}},{16, {{397,{}},}},{18, {{399,{}},}},{65, {{401,{}},}},{73, {{375,{}},}},{95, {{405,{}},}},},
    {{3, {{377,{}},}},},
    {{2, {{38,{1,1,1,1,1,1,}},}},{3, {{38,{1,1,1,1,1,1,}},}},},
    {{2, {{271,{}},}},{3, {{90,{1,1,1,1,0,0,}},}},{85, {{379,{}},}},{87, {{381,{}},}},},
    {{3, {{383,{}},}},},
    {{6, {{417,{}},}},{80, {{385,{}},}},{90, {{387,{}},}},{94, {{393,{}},}},},
    {{3, {{389,{}},}},},
    {{6, {{417,{}},}},{80, {{391,{}},}},{94, {{393,{}},}},},
    {{3, {{395,{}},}},},
    {{2, {{107,{}},}},{16, {{397,{}},}},{18, {{399,{}},}},{65, {{401,{}},}},{73, {{403,{}},}},{95, {{405,{}},}},},
    {{2, {{117,{}},}},{3, {{90,{1,1,1,1,1,0,}},}},{87, {{407,{}},}},},
    {{2, {{123,{}},}},{3, {{90,{1,1,1,1,0,1,}},}},},
    {{1, {{132,{1,1,0,1,1,1,1,1,1,1,}},}},{2, {{132,{1,1,0,1,1,1,1,1,1,1,}},}},{3, {{132,{1,1,0,1,1,1,1,1,1,1,}},}},},
    {{16, {{409,{}},}},{18, {{411,{}},}},{86, {{49,{}},}},},
    {{3, {{413,{}},}},},
    {{1, {{136,{1,1,0,1,1,1,1,1,1,1,}},}},{2, {{136,{1,1,0,1,1,1,1,1,1,1,}},}},{3, {{136,{1,1,0,1,1,1,1,1,1,1,}},}},},
    {{3, {{415,{}},}},},
    {{3, {{96,{1,}},}},{6, {{417,{}},}},{16, {{96,{1,}},}},{18, {{96,{1,}},}},{94, {{51,{}},}},},
    {{1, {{140,{1,1,0,1,1,1,1,1,1,1,}},}},{2, {{140,{1,1,0,1,1,1,1,1,1,1,}},}},{3, {{140,{1,1,0,1,1,1,1,1,1,1,}},}},},
    {{3, {{26,{1,}},}},{16, {{26,{1,}},}},{18, {{26,{1,}},}},{43, {{26,{1,}},}},{45, {{26,{1,}},}},{48, {{26,{1,}},}},{60, {{26,{1,}},}},{61, {{26,{1,}},}},{62, {{26,{1,}},}},{63, {{26,{1,}},}},{65, {{26,{1,}},}},},
    {{3, {{28,{1,}},}},{16, {{28,{1,}},}},{18, {{28,{1,}},}},{43, {{28,{1,}},}},{45, {{28,{1,}},}},{48, {{28,{1,}},}},{60, {{28,{1,}},}},{61, {{28,{1,}},}},{62, {{28,{1,}},}},{63, {{28,{1,}},}},{65, {{28,{1,}},}},},
    {{3, {{24,{1,}},}},{16, {{24,{1,}},}},{18, {{24,{1,}},}},{43, {{24,{1,}},}},{45, {{24,{1,}},}},{48, {{24,{1,}},}},{60, {{24,{1,}},}},{61, {{24,{1,}},}},{62, {{24,{1,}},}},{63, {{24,{1,}},}},{65, {{24,{1,}},}},},
    {{3, {{419,{}},}},},
    {{3, {{102,{1,}},}},{43, {{102,{1,}},}},{45, {{102,{1,}},}},{48, {{102,{1,}},}},{60, {{102,{1,}},}},{61, {{102,{1,}},}},{62, {{102,{1,}},}},{63, {{102,{1,}},}},},
    {{2, {{123,{}},}},{3, {{90,{1,1,1,1,1,1,}},}},},
    {{3, {{30,{1,}},}},},
    {{3, {{32,{1,}},}},},
    {{1, {{132,{1,1,1,1,1,1,1,1,1,1,}},}},{2, {{132,{1,1,1,1,1,1,1,1,1,1,}},}},{3, {{132,{1,1,1,1,1,1,1,1,1,1,}},}},},
    {{1, {{136,{1,1,1,1,1,1,1,1,1,1,}},}},{2, {{136,{1,1,1,1,1,1,1,1,1,1,}},}},{3, {{136,{1,1,1,1,1,1,1,1,1,1,}},}},},
    {{3, {{60,{1,}},}},{6, {{60,{1,}},}},{16, {{60,{1,}},}},{18, {{60,{1,}},}},},
    {{1, {{140,{1,1,1,1,1,1,1,1,1,1,}},}},{2, {{140,{1,1,1,1,1,1,1,1,1,1,}},}},{3, {{140,{1,1,1,1,1,1,1,1,1,1,}},}},},
};

WasmModule Parser::parse(){
    // Prepare
    std::stack<Stack::iterator> branches;
    Stack stack;
    stack.push(fetch(), 0);
    auto throw_error = [&](token_t token, term_t term){
        if(branches.empty()){
            throw ParseError(token.pos, term);
        }
        auto& saved = branches.top();
        auto buf_top = buffer.begin();
        for(auto it = stack.begin(); it != saved; it = std::next(it)){
            if(std::holds_alternative<token_t>(it->elem)){
                buffer.emplace(buf_top, it->term, std::get<token_t>(it->elem));
            }else{
                auto flattened = std::get<Node>(it->elem).flatten();
                buffer.insert(buf_top, flattened.begin(), flattened.end());
            }
        }
        saved->branch += 1;
    };
    // Parse
    while(stack.front().state != End){
        Entry& entry = stack.front();
        State& state = table[entry.state];
        if(state.contains(entry.term)){
            std::vector<Act>& acts = state[entry.term];
            if(entry.branch == 0){
                if(acts.size() > 1){
                    branches.emplace(stack.begin());
                }
            }else if(entry.branch == acts.size() - 1){
                branches.pop();
            }
            Act& act = acts[entry.branch];
            if(act.first & 1){ // Shift
                stack.push(fetch(), act.first >> 1);
            }else{ // Reduce
                if(std::holds_alternative<token_t>(entry.elem)){
                    buffer.emplace_front(entry.term, std::get<token_t>(entry.elem));
                    stack.pop_front();
                }
                stack.reduce(act.first >> 1, act.second);
            }
        }else{
            Entry* ptr = &entry;
            while(std::holds_alternative<Node>(ptr->elem)){
                ptr = &std::get<Node>(ptr->elem).children.front();
            }
            if(std::holds_alternative<token_t>(ptr->elem)){
                throw_error(std::get<token_t>(ptr->elem), entry.term);
            }else{
                throw_error(Token(std::monostate(), Position()), entry.term);
            }
        }
    }
    // Expand tree
    return expand_tree(stack.back());
}

void Parser::Stack::reduce(size_t action, std::vector<bool> param_toggle){
    static const std::vector<term_t> signatures {84,84,84,84,84,84,83,83,83,83,83,95,95,95,86,86,96,96,85,85,85,87,87,70,74,74,77,77,91,94,75,76,67,68,92,92,69,69,89,89,81,81,72,72,93,93,93,80,80,90,73,73,66,66,66,66,66,66,66,78,79,79,79,79,88,88,82,82,71,71,};
    if(action == 0){
        emplace_front(Entry {.term = 0, .state = End});
        return;
    }
    Node node = {.action = action, .param_toggle = param_toggle};
    size_t param_count = std::count_if(param_toggle.begin(), param_toggle.end(), [](bool val){return val;});
    for(size_t i = 0; i < param_count; ++i){
        node.children.emplace_front(front());
        pop_front();
    }
    Entry* head = &node.children.front();
    while(std::holds_alternative<Node>(head->elem)){
        Node& child = std::get<Node>(head->elem);
        head = &child.children.front();
    }
    Entry& entry = emplace_front();
    entry.term = signatures[action - 1];
    entry.state = head->state;
    entry.elem.emplace<Node>(node);
}

using item_t = std::variant<std::monostate,
    Parser::token_t,
    ConstInstr,
    GlobalType,
    Limits,
    RefType,
    TableType,
    ValueType,
    WasmImport,
    WasmModule,
    f32_t,
    f64_t,
    i32_t,
    i64_t,
    std::pair<FuncType, std::map<std::string, index_t>>,
    std::pair<std::vector<ValueType>, std::map<std::string, index_t>>,
    std::string,
    std::variant<Limits, WasmImport>,
    std::variant<TableType, WasmImport>,
    std::variant<WasmGlobal, WasmImport>,
    std::variant<index_t, TableType, MemType, GlobalType>,
    std::vector<ValueType>,
    u32_t
>;

WasmModule Parser::expand_tree(Entry& tree){
    std::list<std::variant<Node, token_t>> entry_stack;
    std::list<std::pair<Position, item_t>> param_stack;
    auto extract_entry = [&](Entry& entry){
        if(std::holds_alternative<token_t>(entry.elem)){
            entry_stack.emplace_front(std::get<token_t>(entry.elem));
        }else if(std::holds_alternative<Node>(entry.elem)){
            Node& elem = std::get<Node>(entry.elem);
            Node& node = std::get<Node>(entry_stack.emplace_front(Node {.action = elem.action, .param_toggle = elem.param_toggle}));
            node.children.swap(elem.children);
        }
    };
    extract_entry(tree);
    auto invoke_action = [&](Node& node){
        std::vector<Position> positions(node.param_toggle.size());
        std::vector<item_t> params(node.param_toggle.size());
        Position pos;
        for(size_t i = node.param_toggle.size(); i > 0; --i){
            size_t index = i - 1;
            if(node.param_toggle[index]){
                positions[index] = param_stack.front().first;
                params[index] = param_stack.front().second;
                param_stack.pop_front();
            }
        }
        for(size_t i = 0; i < node.param_toggle.size(); ++i){
            if(node.param_toggle[i]){
                pos = positions[i];
                break;
            }
        }
        switch(node.action){
            case 1: 
                param_stack.emplace_front(pos, action_1(*this, positions,
                    node.param_toggle[0] ? std::get<WasmModule>(params[0]) : WasmModule()
                ));
            break;
            case 2: 
                param_stack.emplace_front(pos, action_2(*this, positions,
                    node.param_toggle[0] ? std::get<WasmModule>(params[0]) : WasmModule(),
                    node.param_toggle[1] ? std::get<WasmImport>(params[1]) : WasmImport()
                ));
            break;
            case 3: 
                param_stack.emplace_front(pos, action_3(*this, positions,
                    node.param_toggle[0] ? std::get<WasmModule>(params[0]) : WasmModule(),
                    node.param_toggle[1] ? std::get<std::variant<TableType, WasmImport>>(params[1]) : std::variant<TableType, WasmImport>()
                ));
            break;
            case 4: 
                param_stack.emplace_front(pos, action_4(*this, positions,
                    node.param_toggle[0] ? std::get<WasmModule>(params[0]) : WasmModule(),
                    node.param_toggle[1] ? std::get<std::variant<Limits, WasmImport>>(params[1]) : std::variant<Limits, WasmImport>()
                ));
            break;
            case 5: 
                param_stack.emplace_front(pos, action_5(*this, positions,
                    node.param_toggle[0] ? std::get<WasmModule>(params[0]) : WasmModule(),
                    node.param_toggle[1] ? std::get<std::variant<WasmGlobal, WasmImport>>(params[1]) : std::variant<WasmGlobal, WasmImport>()
                ));
            break;
            case 6: 
                param_stack.emplace_front(pos, action_6(*this, positions
                ));
            break;
            case 7: 
                param_stack.emplace_front(pos, action_7(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::ParenL>(std::get<Token>(params[0])) : Tokens::ParenL(),
                    node.param_toggle[1] ? std::get<Tokens::Module>(std::get<Token>(params[1])) : Tokens::Module(),
                    node.param_toggle[2] ? std::get<Tokens::Id>(std::get<Token>(params[2])) : Tokens::Id(),
                    node.param_toggle[3] ? std::get<WasmModule>(params[3]) : WasmModule(),
                    node.param_toggle[4] ? std::get<Tokens::ParenR>(std::get<Token>(params[4])) : Tokens::ParenR()
                ));
            break;
            case 8: 
                param_stack.emplace_front(pos, action_8(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::ParenL>(std::get<Token>(params[0])) : Tokens::ParenL(),
                    node.param_toggle[1] ? std::get<Tokens::Module>(std::get<Token>(params[1])) : Tokens::Module(),
                    node.param_toggle[2] ? std::get<WasmModule>(params[2]) : WasmModule(),
                    node.param_toggle[3] ? std::get<Tokens::ParenR>(std::get<Token>(params[3])) : Tokens::ParenR()
                ));
            break;
            case 9: 
                param_stack.emplace_front(pos, action_9(*this, positions,
                    node.param_toggle[0] ? std::get<WasmModule>(params[0]) : WasmModule()
                ));
            break;
            case 10: 
                param_stack.emplace_front(pos, action_10(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::ParenL>(std::get<Token>(params[0])) : Tokens::ParenL(),
                    node.param_toggle[1] ? std::get<Tokens::ParenR>(std::get<Token>(params[1])) : Tokens::ParenR()
                ));
            break;
            case 11: 
                param_stack.emplace_front(pos, action_11(*this, positions
                ));
            break;
            case 12: 
                param_stack.emplace_front(pos, action_12(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::NumType>(std::get<Token>(params[0])) : Tokens::NumType()
                ));
            break;
            case 13: 
                param_stack.emplace_front(pos, action_13(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Funcref>(std::get<Token>(params[0])) : Tokens::Funcref()
                ));
            break;
            case 14: 
                param_stack.emplace_front(pos, action_14(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Externref>(std::get<Token>(params[0])) : Tokens::Externref()
                ));
            break;
            case 15: 
                param_stack.emplace_front(pos, action_15(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Funcref>(std::get<Token>(params[0])) : Tokens::Funcref()
                ));
            break;
            case 16: 
                param_stack.emplace_front(pos, action_16(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Externref>(std::get<Token>(params[0])) : Tokens::Externref()
                ));
            break;
            case 17: 
                param_stack.emplace_front(pos, action_17(*this, positions,
                    node.param_toggle[0] ? std::get<std::vector<ValueType>>(params[0]) : std::vector<ValueType>(),
                    node.param_toggle[1] ? std::get<ValueType>(params[1]) : ValueType()
                ));
            break;
            case 18: 
                param_stack.emplace_front(pos, action_18(*this, positions
                ));
            break;
            case 19: 
                param_stack.emplace_front(pos, action_19(*this, positions,
                    node.param_toggle[0] ? std::get<std::pair<std::vector<ValueType>, std::map<std::string, index_t>>>(params[0]) : std::pair<std::vector<ValueType>, std::map<std::string, index_t>>(),
                    node.param_toggle[1] ? std::get<Tokens::ParenL>(std::get<Token>(params[1])) : Tokens::ParenL(),
                    node.param_toggle[2] ? std::get<Tokens::Param>(std::get<Token>(params[2])) : Tokens::Param(),
                    node.param_toggle[3] ? std::get<Tokens::Id>(std::get<Token>(params[3])) : Tokens::Id(),
                    node.param_toggle[4] ? std::get<ValueType>(params[4]) : ValueType(),
                    node.param_toggle[5] ? std::get<Tokens::ParenR>(std::get<Token>(params[5])) : Tokens::ParenR()
                ));
            break;
            case 20: 
                param_stack.emplace_front(pos, action_20(*this, positions,
                    node.param_toggle[0] ? std::get<std::pair<std::vector<ValueType>, std::map<std::string, index_t>>>(params[0]) : std::pair<std::vector<ValueType>, std::map<std::string, index_t>>(),
                    node.param_toggle[1] ? std::get<Tokens::ParenL>(std::get<Token>(params[1])) : Tokens::ParenL(),
                    node.param_toggle[2] ? std::get<Tokens::Param>(std::get<Token>(params[2])) : Tokens::Param(),
                    node.param_toggle[3] ? std::get<std::vector<ValueType>>(params[3]) : std::vector<ValueType>(),
                    node.param_toggle[4] ? std::get<Tokens::ParenR>(std::get<Token>(params[4])) : Tokens::ParenR()
                ));
            break;
            case 21: 
                param_stack.emplace_front(pos, action_21(*this, positions
                ));
            break;
            case 22: 
                param_stack.emplace_front(pos, action_22(*this, positions,
                    node.param_toggle[0] ? std::get<std::vector<ValueType>>(params[0]) : std::vector<ValueType>(),
                    node.param_toggle[1] ? std::get<Tokens::ParenL>(std::get<Token>(params[1])) : Tokens::ParenL(),
                    node.param_toggle[2] ? std::get<Tokens::Result>(std::get<Token>(params[2])) : Tokens::Result(),
                    node.param_toggle[3] ? std::get<std::vector<ValueType>>(params[3]) : std::vector<ValueType>(),
                    node.param_toggle[4] ? std::get<Tokens::ParenR>(std::get<Token>(params[4])) : Tokens::ParenR()
                ));
            break;
            case 23: 
                param_stack.emplace_front(pos, action_23(*this, positions
                ));
            break;
            case 24: 
                param_stack.emplace_front(pos, action_24(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::ParenL>(std::get<Token>(params[0])) : Tokens::ParenL(),
                    node.param_toggle[1] ? std::get<Tokens::Func>(std::get<Token>(params[1])) : Tokens::Func(),
                    node.param_toggle[2] ? std::get<std::pair<std::vector<ValueType>, std::map<std::string, index_t>>>(params[2]) : std::pair<std::vector<ValueType>, std::map<std::string, index_t>>(),
                    node.param_toggle[3] ? std::get<std::vector<ValueType>>(params[3]) : std::vector<ValueType>(),
                    node.param_toggle[4] ? std::get<Tokens::ParenR>(std::get<Token>(params[4])) : Tokens::ParenR()
                ));
            break;
            case 25: 
                param_stack.emplace_front(pos, action_25(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Func>(std::get<Token>(params[0])) : Tokens::Func()
                ));
            break;
            case 26: 
                param_stack.emplace_front(pos, action_26(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Extern>(std::get<Token>(params[0])) : Tokens::Extern()
                ));
            break;
            case 27: 
                param_stack.emplace_front(pos, action_27(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Id>(std::get<Token>(params[0])) : Tokens::Id()
                ));
            break;
            case 28: 
                param_stack.emplace_front(pos, action_28(*this, positions
                ));
            break;
            case 29: 
                param_stack.emplace_front(pos, std::monostate());
                action_29(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::ParenL>(std::get<Token>(params[0])) : Tokens::ParenL(),
                    node.param_toggle[1] ? std::get<Tokens::Type>(std::get<Token>(params[1])) : Tokens::Type(),
                    node.param_toggle[2] ? std::get<std::string>(params[2]) : std::string(),
                    node.param_toggle[3] ? std::get<std::pair<FuncType, std::map<std::string, index_t>>>(params[3]) : std::pair<FuncType, std::map<std::string, index_t>>(),
                    node.param_toggle[4] ? std::get<Tokens::ParenR>(std::get<Token>(params[4])) : Tokens::ParenR()
                );
            break;
            case 30: 
                param_stack.emplace_front(pos, action_30(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Integer>(std::get<Token>(params[0])) : Tokens::Integer()
                ));
            break;
            case 31: 
                param_stack.emplace_front(pos, action_31(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Integer>(std::get<Token>(params[0])) : Tokens::Integer()
                ));
            break;
            case 32: 
                param_stack.emplace_front(pos, action_32(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Integer>(std::get<Token>(params[0])) : Tokens::Integer()
                ));
            break;
            case 33: 
                param_stack.emplace_front(pos, action_33(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Float>(std::get<Token>(params[0])) : Tokens::Float()
                ));
            break;
            case 34: 
                param_stack.emplace_front(pos, action_34(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Float>(std::get<Token>(params[0])) : Tokens::Float()
                ));
            break;
            case 35: 
                param_stack.emplace_front(pos, action_35(*this, positions,
                    node.param_toggle[0] ? std::get<u32_t>(params[0]) : u32_t()
                ));
            break;
            case 36: 
                param_stack.emplace_front(pos, action_36(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Id>(std::get<Token>(params[0])) : Tokens::Id()
                ));
            break;
            case 37: 
                param_stack.emplace_front(pos, action_37(*this, positions,
                    node.param_toggle[0] ? std::get<u32_t>(params[0]) : u32_t()
                ));
            break;
            case 38: 
                param_stack.emplace_front(pos, action_38(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Id>(std::get<Token>(params[0])) : Tokens::Id()
                ));
            break;
            case 39: 
                param_stack.emplace_front(pos, action_39(*this, positions,
                    node.param_toggle[0] ? std::get<u32_t>(params[0]) : u32_t()
                ));
            break;
            case 40: 
                param_stack.emplace_front(pos, action_40(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Id>(std::get<Token>(params[0])) : Tokens::Id()
                ));
            break;
            case 41: 
                param_stack.emplace_front(pos, action_41(*this, positions,
                    node.param_toggle[0] ? std::get<u32_t>(params[0]) : u32_t()
                ));
            break;
            case 42: 
                param_stack.emplace_front(pos, action_42(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Id>(std::get<Token>(params[0])) : Tokens::Id()
                ));
            break;
            case 43: 
                param_stack.emplace_front(pos, action_43(*this, positions,
                    node.param_toggle[0] ? std::get<u32_t>(params[0]) : u32_t()
                ));
            break;
            case 44: 
                param_stack.emplace_front(pos, action_44(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Id>(std::get<Token>(params[0])) : Tokens::Id()
                ));
            break;
            case 45: 
                param_stack.emplace_front(pos, action_45(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::ParenL>(std::get<Token>(params[0])) : Tokens::ParenL(),
                    node.param_toggle[1] ? std::get<Tokens::Type>(std::get<Token>(params[1])) : Tokens::Type(),
                    node.param_toggle[2] ? std::get<u32_t>(params[2]) : u32_t(),
                    node.param_toggle[3] ? std::get<Tokens::ParenR>(std::get<Token>(params[3])) : Tokens::ParenR(),
                    node.param_toggle[4] ? std::get<std::pair<std::vector<ValueType>, std::map<std::string, index_t>>>(params[4]) : std::pair<std::vector<ValueType>, std::map<std::string, index_t>>(),
                    node.param_toggle[5] ? std::get<std::vector<ValueType>>(params[5]) : std::vector<ValueType>()
                ));
            break;
            case 46: 
                param_stack.emplace_front(pos, action_46(*this, positions,
                    node.param_toggle[0] ? std::get<std::pair<std::vector<ValueType>, std::map<std::string, index_t>>>(params[0]) : std::pair<std::vector<ValueType>, std::map<std::string, index_t>>(),
                    node.param_toggle[1] ? std::get<std::vector<ValueType>>(params[1]) : std::vector<ValueType>()
                ));
            break;
            case 47: 
                param_stack.emplace_front(pos, action_47(*this, positions
                ));
            break;
            case 48: 
                param_stack.emplace_front(pos, action_48(*this, positions,
                    node.param_toggle[0] ? std::get<u32_t>(params[0]) : u32_t()
                ));
            break;
            case 49: 
                param_stack.emplace_front(pos, action_49(*this, positions,
                    node.param_toggle[0] ? std::get<u32_t>(params[0]) : u32_t(),
                    node.param_toggle[1] ? std::get<u32_t>(params[1]) : u32_t()
                ));
            break;
            case 50: 
                param_stack.emplace_front(pos, action_50(*this, positions,
                    node.param_toggle[0] ? std::get<Limits>(params[0]) : Limits(),
                    node.param_toggle[1] ? std::get<RefType>(params[1]) : RefType()
                ));
            break;
            case 51: 
                param_stack.emplace_front(pos, action_51(*this, positions,
                    node.param_toggle[0] ? std::get<ValueType>(params[0]) : ValueType()
                ));
            break;
            case 52: 
                param_stack.emplace_front(pos, action_52(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::ParenL>(std::get<Token>(params[0])) : Tokens::ParenL(),
                    node.param_toggle[1] ? std::get<Tokens::Mut>(std::get<Token>(params[1])) : Tokens::Mut(),
                    node.param_toggle[2] ? std::get<ValueType>(params[2]) : ValueType(),
                    node.param_toggle[3] ? std::get<Tokens::ParenR>(std::get<Token>(params[3])) : Tokens::ParenR()
                ));
            break;
            case 53: 
                param_stack.emplace_front(pos, action_53(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Ref_null>(std::get<Token>(params[0])) : Tokens::Ref_null(),
                    node.param_toggle[1] ? std::get<RefType>(params[1]) : RefType()
                ));
            break;
            case 54: 
                param_stack.emplace_front(pos, action_54(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::Ref_func>(std::get<Token>(params[0])) : Tokens::Ref_func(),
                    node.param_toggle[1] ? std::get<u32_t>(params[1]) : u32_t()
                ));
            break;
            case 55: 
                param_stack.emplace_front(pos, action_55(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::I32_const>(std::get<Token>(params[0])) : Tokens::I32_const(),
                    node.param_toggle[1] ? std::get<i32_t>(params[1]) : i32_t()
                ));
            break;
            case 56: 
                param_stack.emplace_front(pos, action_56(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::I64_const>(std::get<Token>(params[0])) : Tokens::I64_const(),
                    node.param_toggle[1] ? std::get<i64_t>(params[1]) : i64_t()
                ));
            break;
            case 57: 
                param_stack.emplace_front(pos, action_57(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::F32_const>(std::get<Token>(params[0])) : Tokens::F32_const(),
                    node.param_toggle[1] ? std::get<f32_t>(params[1]) : f32_t()
                ));
            break;
            case 58: 
                param_stack.emplace_front(pos, action_58(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::F64_const>(std::get<Token>(params[0])) : Tokens::F64_const(),
                    node.param_toggle[1] ? std::get<f64_t>(params[1]) : f64_t()
                ));
            break;
            case 59: 
                param_stack.emplace_front(pos, action_59(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::VariableInstr>(std::get<Token>(params[0])) : Tokens::VariableInstr(),
                    node.param_toggle[1] ? std::get<u32_t>(params[1]) : u32_t()
                ));
            break;
            case 60: 
                param_stack.emplace_front(pos, action_60(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::ParenL>(std::get<Token>(params[0])) : Tokens::ParenL(),
                    node.param_toggle[1] ? std::get<Tokens::Import>(std::get<Token>(params[1])) : Tokens::Import(),
                    node.param_toggle[2] ? std::get<Tokens::String>(std::get<Token>(params[2])) : Tokens::String(),
                    node.param_toggle[3] ? std::get<Tokens::String>(std::get<Token>(params[3])) : Tokens::String(),
                    node.param_toggle[4] ? std::get<std::variant<index_t, TableType, MemType, GlobalType>>(params[4]) : std::variant<index_t, TableType, MemType, GlobalType>(),
                    node.param_toggle[5] ? std::get<Tokens::ParenR>(std::get<Token>(params[5])) : Tokens::ParenR()
                ));
            break;
            case 61: 
                param_stack.emplace_front(pos, action_61(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::ParenL>(std::get<Token>(params[0])) : Tokens::ParenL(),
                    node.param_toggle[1] ? std::get<Tokens::Func>(std::get<Token>(params[1])) : Tokens::Func(),
                    node.param_toggle[2] ? std::get<std::string>(params[2]) : std::string(),
                    node.param_toggle[3] ? std::get<u32_t>(params[3]) : u32_t(),
                    node.param_toggle[4] ? std::get<Tokens::ParenR>(std::get<Token>(params[4])) : Tokens::ParenR()
                ));
            break;
            case 62: 
                param_stack.emplace_front(pos, action_62(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::ParenL>(std::get<Token>(params[0])) : Tokens::ParenL(),
                    node.param_toggle[1] ? std::get<Tokens::Table>(std::get<Token>(params[1])) : Tokens::Table(),
                    node.param_toggle[2] ? std::get<std::string>(params[2]) : std::string(),
                    node.param_toggle[3] ? std::get<TableType>(params[3]) : TableType(),
                    node.param_toggle[4] ? std::get<Tokens::ParenR>(std::get<Token>(params[4])) : Tokens::ParenR()
                ));
            break;
            case 63: 
                param_stack.emplace_front(pos, action_63(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::ParenL>(std::get<Token>(params[0])) : Tokens::ParenL(),
                    node.param_toggle[1] ? std::get<Tokens::Memory>(std::get<Token>(params[1])) : Tokens::Memory(),
                    node.param_toggle[2] ? std::get<std::string>(params[2]) : std::string(),
                    node.param_toggle[3] ? std::get<Limits>(params[3]) : Limits(),
                    node.param_toggle[4] ? std::get<Tokens::ParenR>(std::get<Token>(params[4])) : Tokens::ParenR()
                ));
            break;
            case 64: 
                param_stack.emplace_front(pos, action_64(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::ParenL>(std::get<Token>(params[0])) : Tokens::ParenL(),
                    node.param_toggle[1] ? std::get<Tokens::Global>(std::get<Token>(params[1])) : Tokens::Global(),
                    node.param_toggle[2] ? std::get<std::string>(params[2]) : std::string(),
                    node.param_toggle[3] ? std::get<GlobalType>(params[3]) : GlobalType(),
                    node.param_toggle[4] ? std::get<Tokens::ParenR>(std::get<Token>(params[4])) : Tokens::ParenR()
                ));
            break;
            case 65: 
                param_stack.emplace_front(pos, action_65(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::ParenL>(std::get<Token>(params[0])) : Tokens::ParenL(),
                    node.param_toggle[1] ? std::get<Tokens::Table>(std::get<Token>(params[1])) : Tokens::Table(),
                    node.param_toggle[2] ? std::get<std::string>(params[2]) : std::string(),
                    node.param_toggle[3] ? std::get<TableType>(params[3]) : TableType(),
                    node.param_toggle[4] ? std::get<Tokens::ParenR>(std::get<Token>(params[4])) : Tokens::ParenR()
                ));
            break;
            case 66: 
                param_stack.emplace_front(pos, action_66(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::ParenL>(std::get<Token>(params[0])) : Tokens::ParenL(),
                    node.param_toggle[1] ? std::get<Tokens::Table>(std::get<Token>(params[1])) : Tokens::Table(),
                    node.param_toggle[2] ? std::get<std::string>(params[2]) : std::string(),
                    node.param_toggle[3] ? std::get<Tokens::ParenL>(std::get<Token>(params[3])) : Tokens::ParenL(),
                    node.param_toggle[4] ? std::get<Tokens::Import>(std::get<Token>(params[4])) : Tokens::Import(),
                    node.param_toggle[5] ? std::get<Tokens::String>(std::get<Token>(params[5])) : Tokens::String(),
                    node.param_toggle[6] ? std::get<Tokens::String>(std::get<Token>(params[6])) : Tokens::String(),
                    node.param_toggle[7] ? std::get<Tokens::ParenR>(std::get<Token>(params[7])) : Tokens::ParenR(),
                    node.param_toggle[8] ? std::get<TableType>(params[8]) : TableType(),
                    node.param_toggle[9] ? std::get<Tokens::ParenR>(std::get<Token>(params[9])) : Tokens::ParenR()
                ));
            break;
            case 67: 
                param_stack.emplace_front(pos, action_67(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::ParenL>(std::get<Token>(params[0])) : Tokens::ParenL(),
                    node.param_toggle[1] ? std::get<Tokens::Memory>(std::get<Token>(params[1])) : Tokens::Memory(),
                    node.param_toggle[2] ? std::get<std::string>(params[2]) : std::string(),
                    node.param_toggle[3] ? std::get<Limits>(params[3]) : Limits(),
                    node.param_toggle[4] ? std::get<Tokens::ParenR>(std::get<Token>(params[4])) : Tokens::ParenR()
                ));
            break;
            case 68: 
                param_stack.emplace_front(pos, action_68(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::ParenL>(std::get<Token>(params[0])) : Tokens::ParenL(),
                    node.param_toggle[1] ? std::get<Tokens::Memory>(std::get<Token>(params[1])) : Tokens::Memory(),
                    node.param_toggle[2] ? std::get<std::string>(params[2]) : std::string(),
                    node.param_toggle[3] ? std::get<Tokens::ParenL>(std::get<Token>(params[3])) : Tokens::ParenL(),
                    node.param_toggle[4] ? std::get<Tokens::Import>(std::get<Token>(params[4])) : Tokens::Import(),
                    node.param_toggle[5] ? std::get<Tokens::String>(std::get<Token>(params[5])) : Tokens::String(),
                    node.param_toggle[6] ? std::get<Tokens::String>(std::get<Token>(params[6])) : Tokens::String(),
                    node.param_toggle[7] ? std::get<Tokens::ParenR>(std::get<Token>(params[7])) : Tokens::ParenR(),
                    node.param_toggle[8] ? std::get<Limits>(params[8]) : Limits(),
                    node.param_toggle[9] ? std::get<Tokens::ParenR>(std::get<Token>(params[9])) : Tokens::ParenR()
                ));
            break;
            case 69: 
                param_stack.emplace_front(pos, action_69(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::ParenL>(std::get<Token>(params[0])) : Tokens::ParenL(),
                    node.param_toggle[1] ? std::get<Tokens::Global>(std::get<Token>(params[1])) : Tokens::Global(),
                    node.param_toggle[2] ? std::get<std::string>(params[2]) : std::string(),
                    node.param_toggle[3] ? std::get<GlobalType>(params[3]) : GlobalType(),
                    node.param_toggle[4] ? std::get<ConstInstr>(params[4]) : ConstInstr(),
                    node.param_toggle[5] ? std::get<Tokens::ParenR>(std::get<Token>(params[5])) : Tokens::ParenR()
                ));
            break;
            case 70: 
                param_stack.emplace_front(pos, action_70(*this, positions,
                    node.param_toggle[0] ? std::get<Tokens::ParenL>(std::get<Token>(params[0])) : Tokens::ParenL(),
                    node.param_toggle[1] ? std::get<Tokens::Global>(std::get<Token>(params[1])) : Tokens::Global(),
                    node.param_toggle[2] ? std::get<std::string>(params[2]) : std::string(),
                    node.param_toggle[3] ? std::get<Tokens::ParenL>(std::get<Token>(params[3])) : Tokens::ParenL(),
                    node.param_toggle[4] ? std::get<Tokens::Import>(std::get<Token>(params[4])) : Tokens::Import(),
                    node.param_toggle[5] ? std::get<Tokens::String>(std::get<Token>(params[5])) : Tokens::String(),
                    node.param_toggle[6] ? std::get<Tokens::String>(std::get<Token>(params[6])) : Tokens::String(),
                    node.param_toggle[7] ? std::get<Tokens::ParenR>(std::get<Token>(params[7])) : Tokens::ParenR(),
                    node.param_toggle[8] ? std::get<GlobalType>(params[8]) : GlobalType(),
                    node.param_toggle[9] ? std::get<Tokens::ParenR>(std::get<Token>(params[9])) : Tokens::ParenR()
                ));
            break;
            default:
            break;
        }
    };
    while(!entry_stack.empty()){
        std::variant<Node, token_t>& entry = entry_stack.front();
        if(std::holds_alternative<token_t>(entry)){
            token_t token = std::get<token_t>(entry);
            param_stack.emplace_front(token.pos, token);
            entry_stack.pop_front();
        }else if(std::holds_alternative<Node>(entry)){
            Node& node = std::get<Node>(entry);
            if(node.children.size() > 0){
                for(auto it = node.children.rbegin(); it != node.children.rend(); it = std::next(it)){
                    extract_entry(*it);
                }
                node.children.clear();
            }else{
                invoke_action(node);
                entry_stack.pop_front();
            }
        }
    }
    return std::get<WasmModule>(param_stack.front().second);
}

std::list<std::pair<Parser::term_t,Parser::token_t>> Parser::Node::flatten(){
    std::list<std::pair<term_t,token_t>> results;
    for(Entry& child : children){
        if(std::holds_alternative<token_t>(child.elem)){
            results.emplace_back(child.term, std::get<token_t>(child.elem));
        }else{
            auto flattened = std::get<Node>(child.elem).flatten();
            results.insert(results.end(), flattened.begin(), flattened.end());
        }
    }
    return results;
}

WasmVM::ParseError::ParseError(Position pos, Parser::term_t term) : pos(pos) {
    static const std::vector<std::string> terms {
        "",
        "EOF",
        "ParenL",
        "ParenR",
        "Id",
        "String",
        "Integer",
        "Float",
        "MemOffset",
        "MemAlign",
        "Module",
        "Type",
        "Import",
        "Export",
        "Param",
        "Result",
        "Funcref",
        "Extern",
        "Externref",
        "Func",
        "Table",
        "Memory",
        "Global",
        "Mut",
        "Local",
        "Elem",
        "Item",
        "Declare",
        "Offset",
        "Data",
        "Start",
        "Then",
        "ControlInstr",
        "Block",
        "End",
        "Loop",
        "If",
        "Else",
        "Br",
        "Br_if",
        "Br_table",
        "Call",
        "Call_indirect",
        "Ref_null",
        "Ref_is_null",
        "Ref_func",
        "Drop",
        "Select",
        "VariableInstr",
        "TableInstr",
        "Table_copy",
        "Table_init",
        "Elem_drop",
        "Memory_size",
        "Memory_grow",
        "Memory_fill",
        "Memory_init",
        "Memory_copy",
        "Data_drop",
        "MemoryInstr",
        "I32_const",
        "I64_const",
        "F32_const",
        "F64_const",
        "NumericInstr",
        "NumType",
        "constexpr",
        "f32",
        "f64",
        "funcidx",
        "functype",
        "global",
        "globalidx",
        "globaltype",
        "heaptype",
        "i32",
        "i64",
        "id",
        "import",
        "importdesc",
        "limits",
        "memidx",
        "memory",
        "module",
        "modulefield",
        "params",
        "reftype",
        "results",
        "table",
        "tableidx",
        "tabletype",
        "type",
        "typeidx",
        "typeuse",
        "u32",
        "valtype",
        "valtypes",
    };
    msg = "unexpected " + terms[term];
}
} // namespace WasmVM


namespace WasmVM {
index_t Parser::IndexMap::insert(IndexType type){
    index_t index = handlers.size();
    handlers.emplace_back(indices.emplace(type, serial++).first);
    return index;
}
index_t Parser::IndexMap::insert(std::string id, IndexType type){
    if(!id_map.contains(id)){
        id_map[id] = insert(type);
    }
    return id_map[id];
}
index_t Parser::IndexMap::get(std::string id){
    return id_map.contains(id) ? id_map[id] : -1;
}
bool Parser::IndexMap::contains(std::string id){
    return id_map.contains(id);
}
std::optional<Parser::IndexMap::Index> Parser::IndexMap::operator[](index_t index){
    if(index < handlers.size()){
        return *handlers[index];
    }
    return std::nullopt;
}
void Parser::reset(){
    types.clear();
    type_indices.clear();
    func_indices = IndexMap();
    table_indices = IndexMap();
    mem_indices = IndexMap();
    global_indices = IndexMap();
}
} // namespace WasmVM
        
