<!DOCTYPE pxml>
<pxml namespace="WasmVM">
    <lexer class="Lexer" newLine="\n" headerFile="Lexer.hpp" sourceFile="Lexer.cpp">
        {% Block comment %}
        <rule id="Block comment" pattern="\(;" push="block-comment" />
        <group name="block-comment">
            <use id="Block comment" />
            <rule pattern=";\)" pop />
            <rule pattern="\(" />
            <rule pattern=";" />
            <rule pattern="." />
            <rule pattern="$">
                throw Exception::Parse("block comment not close", {_pos.line, _pos.column});
            </rule>
        </group>
        {% Line comment %}
        <rule id="Line comment" pattern=";;" push="line-comment" />
        <group name="line-comment">
            <rule pattern="(\n|$)" pop />
            <rule pattern="." />
        </group>
        {% white space %}
        <rule pattern="( |\t|\n|\r)" />
        {% parenthesis %}
        <rule pattern="\(">
            return Token(ParenL(), _pos);
        </rule>
        <rule pattern="\)">
            return Token(ParenR(), _pos);
        </rule>
        {% id %}
        <rule pattern="\$[0-9a-zA-Z!#%&'*+\-./:<=>@_`\|~\$\^\\?]+">
            return Token(Id(_text.substr(1)), _pos);
        </rule>
        {% string %}
        <rule pattern="\"" push="string" />
        <group name="string">
            <rule pattern="([\x01-\x1f\x7f])">
                throw Exception::Parse("invalid character in string", {_pos.line, _pos.column});
            </rule>
            <rule pattern="$">
                throw Exception::Parse("string not close", {_pos.line, _pos.column});
            </rule>
            <rule pattern="." more />
            <rule pattern="\"" pop>
                return Token(String(_text.substr(0, _text.size() - 1)), _pos);
            </rule>
        </group>
        {% Integer %}
        <rule pattern="[\+\-]?\d[\d_]*">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("integer can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(Integer(_text), _pos);
        </rule>
        <rule pattern="[\+\-]?0x[\da-fA-F][\da-fA-F_]*">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("integer can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(Integer(_text), _pos);
        </rule>
        {% Floating %}
        <rule pattern="[\+\-]?(nan|nan:0x[\da-fA-F][\da-fA-F_]*|inf)">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("floating number can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(Float(_text), _pos);
        </rule>
        <rule pattern="[\+\-]?\d[\d_]*([Ee][\+\-]?\d[\d_]*|\.(\d[\d_]*)?([Ee][\+\-]?\d[\d_]*)?)">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("floating number can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(Float(_text), _pos);
        </rule>
        <rule pattern="[\+\-]?0x[\da-fA-F][\da-fA-F_]*([Pp][\+\-]?\d[\d_]*|\.([\da-fA-F][\da-fA-F_]*)?([Pp][\+\-]?\d[\d_]*)?)">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("floating number can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(Float(_text), _pos);
        </rule>
        {% offset %}
        <rule pattern="offset=\d[\d_]*">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("offset can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(MemOffset(std::stoll(_text.substr(7))), _pos);
        </rule>
        <rule pattern="offset=0x[\da-fA-F][\da-fA-F_]*">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("offset can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(MemOffset(std::stoll(_text.substr(7), nullptr, 16)), _pos);
        </rule>
        {% align %}
        <rule pattern="align=\d[\d_]*">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("align can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(MemAlign(std::stoll(_text.substr(6))), _pos);
        </rule>
        <rule pattern="align=0x[\da-fA-F][\da-fA-F_]*">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("align can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(MemAlign(std::stoll(_text.substr(6), nullptr, 16)), _pos);
        </rule>
        {% keywords %}
        <rule pattern="module">
            return Token(Module(), _pos);
        </rule>    
        <rule pattern="type">
            return Token(Type(), _pos);
        </rule>    
        <rule pattern="import">
            return Token(Import(), _pos);
        </rule>    
        <rule pattern="export">
            return Token(Export(), _pos);
        </rule>    
        <rule pattern="param">
            return Token(Param(), _pos);
        </rule>    
        <rule pattern="result">
            return Token(Result(), _pos);
        </rule>    
        <rule pattern="funcref">
            return Token(Funcref(), _pos);
        </rule>    
        <rule pattern="extern">
            return Token(Extern(), _pos);
        </rule>    
        <rule pattern="externref">
            return Token(Externref(), _pos);
        </rule>    
        <rule pattern="[if](32|64)">
            return Token(NumType(_text), _pos);
        </rule>     
        <rule pattern="func">
            return Token(Func(), _pos);
        </rule>    
        <rule pattern="table">
            return Token(Table(), _pos);
        </rule>    
        <rule pattern="memory">
            return Token(Memory(), _pos);
        </rule>    
        <rule pattern="global">
            return Token(Global(), _pos);
        </rule>    
        <rule pattern="mut">
            return Token(Mut(), _pos);
        </rule>    
        <rule pattern="local">
            return Token(Local(), _pos);
        </rule>    
        <rule pattern="elem">
            return Token(Elem(), _pos);
        </rule>    
        <rule pattern="item">
            return Token(Item(), _pos);
        </rule>    
        <rule pattern="declare">
            return Token(Declare(), _pos);
        </rule>    
        <rule pattern="offset">
            return Token(Offset(), _pos);
        </rule>    
        <rule pattern="data">
            return Token(Data(), _pos);
        </rule>    
        <rule pattern="start">
            return Token(Start(), _pos);
        </rule>
        <rule pattern="then">
            return Token(Then(), _pos);
        </rule>
        <rule pattern="unreachable">
            return Token(ControlInstr(ControlInstr::Unreachable), _pos);
        </rule>
        <rule pattern="block">
            return Token(Block(), _pos);
        </rule>
        <rule pattern="nop">
            return Token(ControlInstr(ControlInstr::Nop), _pos);
        </rule>
        <rule pattern="end">
            return Token(End(), _pos);
        </rule>
        <rule pattern="loop">
            return Token(Loop(), _pos);
        </rule>
        <rule pattern="if">
            return Token(If(), _pos);
        </rule>
        <rule pattern="else">
            return Token(Else(), _pos);
        </rule>
        <rule pattern="br">
            return Token(Br(), _pos);
        </rule>
        <rule pattern="br_if">
            return Token(Br_if(), _pos);
        </rule>
        <rule pattern="br_table">
            return Token(Br_table(), _pos);
        </rule>
        <rule pattern="return">
            return Token(ControlInstr(ControlInstr::Return), _pos);
        </rule>
        <rule pattern="call">
            return Token(Call(), _pos);
        </rule>
        <rule pattern="call_indirect">
            return Token(Call_indirect(), _pos);
        </rule>
        <rule pattern="ref\.null">
            return Token(Ref_null(), _pos);
        </rule>
        <rule pattern="ref\.is_null">
            return Token(Ref_is_null(), _pos);
        </rule>
        <rule pattern="ref\.func">
            return Token(Ref_func(), _pos);
        </rule>
        <rule pattern="drop">
            return Token(Drop(), _pos);
        </rule>
        <rule pattern="select">
            return Token(Select(), _pos);
        </rule>
        <rule pattern="local\.get">
            return Token(VariableInstr(VariableInstr::LocalGet), _pos);
        </rule>
        <rule pattern="local\.set">
            return Token(VariableInstr(VariableInstr::LocalSet), _pos);
        </rule>
        <rule pattern="local\.tee">
            return Token(VariableInstr(VariableInstr::LocalTee), _pos);
        </rule>
        <rule pattern="global\.get">
            return Token(VariableInstr(VariableInstr::GlobalGet), _pos);
        </rule>
        <rule pattern="global\.set">
            return Token(VariableInstr(VariableInstr::GlobalSet), _pos);
        </rule>
        <rule pattern="table\.get">
            return Token(TableInstr(TableInstr::TableGet), _pos);
        </rule>
        <rule pattern="table\.set">
            return Token(TableInstr(TableInstr::TableSet), _pos);
        </rule>
        <rule pattern="table\.size">
            return Token(TableInstr(TableInstr::TableSize), _pos);
        </rule>
        <rule pattern="table\.grow">
            return Token(TableInstr(TableInstr::TableGrow), _pos);
        </rule>
        <rule pattern="table\.fill">
            return Token(TableInstr(TableInstr::TableFill), _pos);
        </rule>
        <rule pattern="table\.copy">
            return Token(Table_copy(), _pos);
        </rule>
        <rule pattern="table\.init">
            return Token(Table_init(), _pos);
        </rule>
        <rule pattern="elem\.drop">
            return Token(Elem_drop(), _pos);
        </rule>
        <rule pattern="memory\.size">
            return Token(Memory_size(), _pos);
        </rule>
        <rule pattern="memory\.grow">
            return Token(Memory_grow(), _pos);
        </rule>
        <rule pattern="memory\.fill">
            return Token(Memory_fill(), _pos);
        </rule>
        <rule pattern="memory\.init">
            return Token(Memory_init(), _pos);
        </rule>
        <rule pattern="memory\.copy">
            return Token(Memory_copy(), _pos);
        </rule>
        <rule pattern="data\.drop">
            return Token(Data_drop(), _pos);
        </rule>
        <rule pattern="i32\.load">
            return Token(MemoryInstr(MemoryInstr::I32Load), _pos);
        </rule>
        <rule pattern="i64\.load">
            return Token(MemoryInstr(MemoryInstr::I64Load), _pos);
        </rule>
        <rule pattern="f32\.load">
            return Token(MemoryInstr(MemoryInstr::F32Load), _pos);
        </rule>
        <rule pattern="f64\.load">
            return Token(MemoryInstr(MemoryInstr::F64Load), _pos);
        </rule>
        <rule pattern="i32\.load8_s">
            return Token(MemoryInstr(MemoryInstr::I32Load8_s), _pos);
        </rule>
        <rule pattern="i32\.load8_u">
            return Token(MemoryInstr(MemoryInstr::I32Load8_u), _pos);
        </rule>
        <rule pattern="i32\.load16_s">
            return Token(MemoryInstr(MemoryInstr::I32Load16_s), _pos);
        </rule>
        <rule pattern="i32\.load16_u">
            return Token(MemoryInstr(MemoryInstr::I32Load16_u), _pos);
        </rule>
        <rule pattern="i64\.load8_s">
            return Token(MemoryInstr(MemoryInstr::I64Load8_s), _pos);
        </rule>
        <rule pattern="i64\.load8_u">
            return Token(MemoryInstr(MemoryInstr::I64Load8_u), _pos);
        </rule>
        <rule pattern="i64\.load16_s">
            return Token(MemoryInstr(MemoryInstr::I64Load16_s), _pos);
        </rule>
        <rule pattern="i64\.load16_u">
            return Token(MemoryInstr(MemoryInstr::I64Load16_u), _pos);
        </rule>
        <rule pattern="i64\.load32_s">
            return Token(MemoryInstr(MemoryInstr::I64Load32_s), _pos);
        </rule>
        <rule pattern="i64\.load32_u">
            return Token(MemoryInstr(MemoryInstr::I64Load32_u), _pos);
        </rule>
        <rule pattern="i32\.store">
            return Token(MemoryInstr(MemoryInstr::I32Store), _pos);
        </rule>
        <rule pattern="i64\.store">
            return Token(MemoryInstr(MemoryInstr::I64Store), _pos);
        </rule>
        <rule pattern="f32\.store">
            return Token(MemoryInstr(MemoryInstr::F32Store), _pos);
        </rule>
        <rule pattern="f64\.store">
            return Token(MemoryInstr(MemoryInstr::F64Store), _pos);
        </rule>
        <rule pattern="i32\.store8">
            return Token(MemoryInstr(MemoryInstr::I32Store8), _pos);
        </rule>
        <rule pattern="i32\.store16">
            return Token(MemoryInstr(MemoryInstr::I32Store16), _pos);
        </rule>
        <rule pattern="i64\.store8">
            return Token(MemoryInstr(MemoryInstr::I64Store8), _pos);
        </rule>
        <rule pattern="i64\.store16">
            return Token(MemoryInstr(MemoryInstr::I64Store16), _pos);
        </rule>
        <rule pattern="i64\.store32">
            return Token(MemoryInstr(MemoryInstr::I64Store32), _pos);
        </rule>
        <rule pattern="i32\.const">
            return Token(I32_const(), _pos);
        </rule>
        <rule pattern="i64\.const">
            return Token(I64_const(), _pos);
        </rule>
        <rule pattern="f32\.const">
            return Token(F32_const(), _pos);
        </rule>
        <rule pattern="f64\.const">
            return Token(F64_const(), _pos);
        </rule>
        <rule pattern="i32\.eqz">
            return Token(NumericInstr(NumericInstr::I32Eqz), _pos);
        </rule>
        <rule pattern="i32\.eq">
            return Token(NumericInstr(NumericInstr::I32Eq), _pos);
        </rule>
        <rule pattern="i32\.ne">
            return Token(NumericInstr(NumericInstr::I32Ne), _pos);
        </rule>
        <rule pattern="i32\.lt_s">
            return Token(NumericInstr(NumericInstr::I32Lt_s), _pos);
        </rule>
        <rule pattern="i32\.lt_u">
            return Token(NumericInstr(NumericInstr::I32Lt_u), _pos);
        </rule>
        <rule pattern="i32\.gt_s">
            return Token(NumericInstr(NumericInstr::I32Gt_s), _pos);
        </rule>
        <rule pattern="i32\.gt_u">
            return Token(NumericInstr(NumericInstr::I32Gt_u), _pos);
        </rule>
        <rule pattern="i32\.le_s">
            return Token(NumericInstr(NumericInstr::I32Le_s), _pos);
        </rule>
        <rule pattern="i32\.le_u">
            return Token(NumericInstr(NumericInstr::I32Le_u), _pos);
        </rule>
        <rule pattern="i32\.ge_s">
            return Token(NumericInstr(NumericInstr::I32Ge_s), _pos);
        </rule>
        <rule pattern="i32\.ge_u">
            return Token(NumericInstr(NumericInstr::I32Ge_u), _pos);
        </rule>
        <rule pattern="i64\.eqz">
            return Token(NumericInstr(NumericInstr::I64Eqz), _pos);
        </rule>
        <rule pattern="i64\.eq">
            return Token(NumericInstr(NumericInstr::I64Eq), _pos);
        </rule>
        <rule pattern="i64\.ne">
            return Token(NumericInstr(NumericInstr::I64Ne), _pos);
        </rule>
        <rule pattern="i64\.lt_s">
            return Token(NumericInstr(NumericInstr::I64Lt_s), _pos);
        </rule>
        <rule pattern="i64\.lt_u">
            return Token(NumericInstr(NumericInstr::I64Lt_u), _pos);
        </rule>
        <rule pattern="i64\.gt_s">
            return Token(NumericInstr(NumericInstr::I64Gt_s), _pos);
        </rule>
        <rule pattern="i64\.gt_u">
            return Token(NumericInstr(NumericInstr::I64Gt_u), _pos);
        </rule>
        <rule pattern="i64\.le_s">
            return Token(NumericInstr(NumericInstr::I64Le_s), _pos);
        </rule>
        <rule pattern="i64\.le_u">
            return Token(NumericInstr(NumericInstr::I64Le_u), _pos);
        </rule>
        <rule pattern="i64\.ge_s">
            return Token(NumericInstr(NumericInstr::I64Ge_s), _pos);
        </rule>
        <rule pattern="i64\.ge_u">
            return Token(NumericInstr(NumericInstr::I64Ge_u), _pos);
        </rule>
        <rule pattern="f32\.eq">
            return Token(NumericInstr(NumericInstr::F32Eq), _pos);
        </rule>
        <rule pattern="f32\.ne">
            return Token(NumericInstr(NumericInstr::F32Ne), _pos);
        </rule>
        <rule pattern="f32\.lt">
            return Token(NumericInstr(NumericInstr::F32Lt), _pos);
        </rule>
        <rule pattern="f32\.gt">
            return Token(NumericInstr(NumericInstr::F32Gt), _pos);
        </rule>
        <rule pattern="f32\.le">
            return Token(NumericInstr(NumericInstr::F32Le), _pos);
        </rule>
        <rule pattern="f32\.ge">
            return Token(NumericInstr(NumericInstr::F32Ge), _pos);
        </rule>
        <rule pattern="f64\.eq">
            return Token(NumericInstr(NumericInstr::F64Eq), _pos);
        </rule>
        <rule pattern="f64\.ne">
            return Token(NumericInstr(NumericInstr::F64Ne), _pos);
        </rule>
        <rule pattern="f64\.lt">
            return Token(NumericInstr(NumericInstr::F64Lt), _pos);
        </rule>
        <rule pattern="f64\.gt">
            return Token(NumericInstr(NumericInstr::F64Gt), _pos);
        </rule>
        <rule pattern="f64\.le">
            return Token(NumericInstr(NumericInstr::F64Le), _pos);
        </rule>
        <rule pattern="f64\.ge">
            return Token(NumericInstr(NumericInstr::F64Ge), _pos);
        </rule>
        <rule pattern="i32\.clz">
            return Token(NumericInstr(NumericInstr::I32Clz), _pos);
        </rule>
        <rule pattern="i32\.ctz">
            return Token(NumericInstr(NumericInstr::I32Ctz), _pos);
        </rule>
        <rule pattern="i32\.popcnt">
            return Token(NumericInstr(NumericInstr::I32Popcnt), _pos);
        </rule>
        <rule pattern="i32\.add">
            return Token(NumericInstr(NumericInstr::I32Add), _pos);
        </rule>
        <rule pattern="i32\.sub">
            return Token(NumericInstr(NumericInstr::I32Sub), _pos);
        </rule>
        <rule pattern="i32\.mul">
            return Token(NumericInstr(NumericInstr::I32Mul), _pos);
        </rule>
        <rule pattern="i32\.div_s">
            return Token(NumericInstr(NumericInstr::I32Div_s), _pos);
        </rule>
        <rule pattern="i32\.div_u">
            return Token(NumericInstr(NumericInstr::I32Div_u), _pos);
        </rule>
        <rule pattern="i32\.rem_s">
            return Token(NumericInstr(NumericInstr::I32Rem_s), _pos);
        </rule>
        <rule pattern="i32\.rem_u">
            return Token(NumericInstr(NumericInstr::I32Rem_u), _pos);
        </rule>
        <rule pattern="i32\.and">
            return Token(NumericInstr(NumericInstr::I32And), _pos);
        </rule>
        <rule pattern="i32\.or">
            return Token(NumericInstr(NumericInstr::I32Or), _pos);
        </rule>
        <rule pattern="i32\.xor">
            return Token(NumericInstr(NumericInstr::I32Xor), _pos);
        </rule>
        <rule pattern="i32\.shl">
            return Token(NumericInstr(NumericInstr::I32Shl), _pos);
        </rule>
        <rule pattern="i32\.shr_s">
            return Token(NumericInstr(NumericInstr::I32Shr_s), _pos);
        </rule>
        <rule pattern="i32\.shr_u">
            return Token(NumericInstr(NumericInstr::I32Shr_u), _pos);
        </rule>
        <rule pattern="i32\.rotl">
            return Token(NumericInstr(NumericInstr::I32Rotl), _pos);
        </rule>
        <rule pattern="i32\.rotr">
            return Token(NumericInstr(NumericInstr::I32Rotr), _pos);
        </rule>
        <rule pattern="i64\.clz">
            return Token(NumericInstr(NumericInstr::I64Clz), _pos);
        </rule>
        <rule pattern="i64\.ctz">
            return Token(NumericInstr(NumericInstr::I64Ctz), _pos);
        </rule>
        <rule pattern="i64\.popcnt">
            return Token(NumericInstr(NumericInstr::I64Popcnt), _pos);
        </rule>
        <rule pattern="i64\.add">
            return Token(NumericInstr(NumericInstr::I64Add), _pos);
        </rule>
        <rule pattern="i64\.sub">
            return Token(NumericInstr(NumericInstr::I64Sub), _pos);
        </rule>
        <rule pattern="i64\.mul">
            return Token(NumericInstr(NumericInstr::I64Mul), _pos);
        </rule>
        <rule pattern="i64\.div_s">
            return Token(NumericInstr(NumericInstr::I64Div_s), _pos);
        </rule>
        <rule pattern="i64\.div_u">
            return Token(NumericInstr(NumericInstr::I64Div_u), _pos);
        </rule>
        <rule pattern="i64\.rem_s">
            return Token(NumericInstr(NumericInstr::I64Rem_s), _pos);
        </rule>
        <rule pattern="i64\.rem_u">
            return Token(NumericInstr(NumericInstr::I64Rem_u), _pos);
        </rule>
        <rule pattern="i64\.and">
            return Token(NumericInstr(NumericInstr::I64And), _pos);
        </rule>
        <rule pattern="i64\.or">
            return Token(NumericInstr(NumericInstr::I64Or), _pos);
        </rule>
        <rule pattern="i64\.xor">
            return Token(NumericInstr(NumericInstr::I64Xor), _pos);
        </rule>
        <rule pattern="i64\.shl">
            return Token(NumericInstr(NumericInstr::I64Shl), _pos);
        </rule>
        <rule pattern="i64\.shr_s">
            return Token(NumericInstr(NumericInstr::I64Shr_s), _pos);
        </rule>
        <rule pattern="i64\.shr_u">
            return Token(NumericInstr(NumericInstr::I64Shr_u), _pos);
        </rule>
        <rule pattern="i64\.rotl">
            return Token(NumericInstr(NumericInstr::I64Rotl), _pos);
        </rule>
        <rule pattern="i64\.rotr">
            return Token(NumericInstr(NumericInstr::I64Rotr), _pos);
        </rule>
        <rule pattern="f32\.abs">
            return Token(NumericInstr(NumericInstr::F32Abs), _pos);
        </rule>
        <rule pattern="f32\.neg">
            return Token(NumericInstr(NumericInstr::F32Neg), _pos);
        </rule>
        <rule pattern="f32\.ceil">
            return Token(NumericInstr(NumericInstr::F32Ceil), _pos);
        </rule>
        <rule pattern="f32\.floor">
            return Token(NumericInstr(NumericInstr::F32Floor), _pos);
        </rule>
        <rule pattern="f32\.trunc">
            return Token(NumericInstr(NumericInstr::F32Trunc), _pos);
        </rule>
        <rule pattern="f32\.nearest">
            return Token(NumericInstr(NumericInstr::F32Nearest), _pos);
        </rule>
        <rule pattern="f32\.sqrt">
            return Token(NumericInstr(NumericInstr::F32Sqrt), _pos);
        </rule>
        <rule pattern="f32\.add">
            return Token(NumericInstr(NumericInstr::F32Add), _pos);
        </rule>
        <rule pattern="f32\.sub">
            return Token(NumericInstr(NumericInstr::F32Sub), _pos);
        </rule>
        <rule pattern="f32\.mul">
            return Token(NumericInstr(NumericInstr::F32Mul), _pos);
        </rule>
        <rule pattern="f32\.div">
            return Token(NumericInstr(NumericInstr::F32Div), _pos);
        </rule>
        <rule pattern="f32\.min">
            return Token(NumericInstr(NumericInstr::F32Min), _pos);
        </rule>
        <rule pattern="f32\.max">
            return Token(NumericInstr(NumericInstr::F32Max), _pos);
        </rule>
        <rule pattern="f32\.copysign">
            return Token(NumericInstr(NumericInstr::F32Copysign), _pos);
        </rule>
        <rule pattern="f64\.abs">
            return Token(NumericInstr(NumericInstr::F64Abs), _pos);
        </rule>
        <rule pattern="f64\.neg">
            return Token(NumericInstr(NumericInstr::F64Neg), _pos);
        </rule>
        <rule pattern="f64\.ceil">
            return Token(NumericInstr(NumericInstr::F64Ceil), _pos);
        </rule>
        <rule pattern="f64\.floor">
            return Token(NumericInstr(NumericInstr::F64Floor), _pos);
        </rule>
        <rule pattern="f64\.trunc">
            return Token(NumericInstr(NumericInstr::F64Trunc), _pos);
        </rule>
        <rule pattern="f64\.nearest">
            return Token(NumericInstr(NumericInstr::F64Nearest), _pos);
        </rule>
        <rule pattern="f64\.sqrt">
            return Token(NumericInstr(NumericInstr::F64Sqrt), _pos);
        </rule>
        <rule pattern="f64\.add">
            return Token(NumericInstr(NumericInstr::F64Add), _pos);
        </rule>
        <rule pattern="f64\.sub">
            return Token(NumericInstr(NumericInstr::F64Sub), _pos);
        </rule>
        <rule pattern="f64\.mul">
            return Token(NumericInstr(NumericInstr::F64Mul), _pos);
        </rule>
        <rule pattern="f64\.div">
            return Token(NumericInstr(NumericInstr::F64Div), _pos);
        </rule>
        <rule pattern="f64\.min">
            return Token(NumericInstr(NumericInstr::F64Min), _pos);
        </rule>
        <rule pattern="f64\.max">
            return Token(NumericInstr(NumericInstr::F64Max), _pos);
        </rule>
        <rule pattern="f64\.copysign">
            return Token(NumericInstr(NumericInstr::F64Copysign), _pos);
        </rule>
        <rule pattern="i32\.wrap_i64">
            return Token(NumericInstr(NumericInstr::I32Wrap_i64), _pos);
        </rule>
        <rule pattern="i32\.trunc_s_f32">
            return Token(NumericInstr(NumericInstr::I32Trunc_s_f32), _pos);
        </rule>
        <rule pattern="i32\.trunc_u_f32">
            return Token(NumericInstr(NumericInstr::I32Trunc_u_f32), _pos);
        </rule>
        <rule pattern="i32\.trunc_s_f64">
            return Token(NumericInstr(NumericInstr::I32Trunc_s_f64), _pos);
        </rule>
        <rule pattern="i32\.trunc_u_f64">
            return Token(NumericInstr(NumericInstr::I32Trunc_u_f64), _pos);
        </rule>
        <rule pattern="i64\.extend_s_i32">
            return Token(NumericInstr(NumericInstr::I64Extend_s_i32), _pos);
        </rule>
        <rule pattern="i64\.extend_u_i32">
            return Token(NumericInstr(NumericInstr::I64Extend_u_i32), _pos);
        </rule>
        <rule pattern="i64\.trunc_s_f32">
            return Token(NumericInstr(NumericInstr::I64Trunc_s_f32), _pos);
        </rule>
        <rule pattern="i64\.trunc_u_f32">
            return Token(NumericInstr(NumericInstr::I64Trunc_u_f32), _pos);
        </rule>
        <rule pattern="i64\.trunc_s_f64">
            return Token(NumericInstr(NumericInstr::I64Trunc_s_f64), _pos);
        </rule>
        <rule pattern="i64\.trunc_u_f64">
            return Token(NumericInstr(NumericInstr::I64Trunc_u_f64), _pos);
        </rule>
        <rule pattern="f32\.convert_s_i32">
            return Token(NumericInstr(NumericInstr::F32Convert_s_i32), _pos);
        </rule>
        <rule pattern="f32\.convert_u_i32">
            return Token(NumericInstr(NumericInstr::F32Convert_u_i32), _pos);
        </rule>
        <rule pattern="f32\.convert_s_i64">
            return Token(NumericInstr(NumericInstr::F32Convert_s_i64), _pos);
        </rule>
        <rule pattern="f32\.convert_u_i64">
            return Token(NumericInstr(NumericInstr::F32Convert_u_i64), _pos);
        </rule>
        <rule pattern="f32\.demote_f64">
            return Token(NumericInstr(NumericInstr::F32Demote_f64), _pos);
        </rule>
        <rule pattern="f64\.convert_s_i32">
            return Token(NumericInstr(NumericInstr::F64Convert_s_i32), _pos);
        </rule>
        <rule pattern="f64\.convert_u_i32">
            return Token(NumericInstr(NumericInstr::F64Convert_u_i32), _pos);
        </rule>
        <rule pattern="f64\.convert_s_i64">
            return Token(NumericInstr(NumericInstr::F64Convert_s_i64), _pos);
        </rule>
        <rule pattern="f64\.convert_u_i64">
            return Token(NumericInstr(NumericInstr::F64Convert_u_i64), _pos);
        </rule>
        <rule pattern="f64\.promote_f32">
            return Token(NumericInstr(NumericInstr::F64Promote_f32), _pos);
        </rule>
        <rule pattern="i32\.reinterpret_f32">
            return Token(NumericInstr(NumericInstr::I32Reinterpret_f32), _pos);
        </rule>
        <rule pattern="i64\.reinterpret_f64">
            return Token(NumericInstr(NumericInstr::I64Reinterpret_f64), _pos);
        </rule>
        <rule pattern="f32\.reinterpret_i32">
            return Token(NumericInstr(NumericInstr::F32Reinterpret_i32), _pos);
        </rule>
        <rule pattern="f64\.reinterpret_i64">
            return Token(NumericInstr(NumericInstr::F64Reinterpret_i64), _pos);
        </rule>
        <rule pattern="i32\.extend8_s">
            return Token(NumericInstr(NumericInstr::I32Extend8_s), _pos);
        </rule>
        <rule pattern="i32\.extend16_s">
            return Token(NumericInstr(NumericInstr::I32Extend16_s), _pos);
        </rule>
        <rule pattern="i64\.extend8_s">
            return Token(NumericInstr(NumericInstr::I64Extend8_s), _pos);
        </rule>
        <rule pattern="i64\.extend16_s">
            return Token(NumericInstr(NumericInstr::I64Extend16_s), _pos);
        </rule>
        <rule pattern="i64\.extend32_s">
            return Token(NumericInstr(NumericInstr::I64Extend32_s), _pos);
        </rule>
        <rule pattern="i32\.trunc_sat_f32_s">
            return Token(NumericInstr(NumericInstr::I32Trunc_sat_f32_s), _pos);
        </rule>
        <rule pattern="i32\.trunc_sat_f32_u">
            return Token(NumericInstr(NumericInstr::I32Trunc_sat_f32_u), _pos);
        </rule>
        <rule pattern="i32\.trunc_sat_f64_s">
            return Token(NumericInstr(NumericInstr::I32Trunc_sat_f64_s), _pos);
        </rule>
        <rule pattern="i32\.trunc_sat_f64_u">
            return Token(NumericInstr(NumericInstr::I32Trunc_sat_f64_u), _pos);
        </rule>
        <rule pattern="i64\.trunc_sat_f32_s">
            return Token(NumericInstr(NumericInstr::I64Trunc_sat_f32_s), _pos);
        </rule>
        <rule pattern="i64\.trunc_sat_f64_u">
            return Token(NumericInstr(NumericInstr::I64Trunc_sat_f64_u), _pos);
        </rule>
        <rule pattern="i64\.trunc_sat_f64_s">
            return Token(NumericInstr(NumericInstr::I64Trunc_sat_f64_s), _pos);
        </rule>
        <rule pattern="i64\.trunc_sat_f32_u">
            return Token(NumericInstr(NumericInstr::I64Trunc_sat_f32_u), _pos);
        </rule>
    </lexer>
</pxml>