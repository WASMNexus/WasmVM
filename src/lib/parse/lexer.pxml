<!DOCTYPE pxml>
<pxml namespace="WasmVM">
    <lexer class="Lexer" newLine="\n" headerFile="Lexer.hpp" sourceFile="Lexer.cpp">
        {% Block comment %}
        <rule id="Block comment" pattern="\(;" push="block-comment" />
        <group name="block-comment">
            <use id="Block comment" />
            <rule pattern=";\)" pop />
            <rule pattern="\(" />
            <rule pattern=";" />
            <rule pattern="." />
            <rule pattern="$">
                throw Exception::Parse("block comment not close", {_pos.line, _pos.column});
            </rule>
        </group>
        {% Line comment %}
        <rule id="Line comment" pattern=";;" push="line-comment" />
        <group name="line-comment">
            <rule pattern="(\n|$)" pop />
            <rule pattern="." />
        </group>
        {% white space %}
        <rule pattern="( |\t|\n|\r)" />
        {% parenthesis %}
        <rule pattern="\(">
            return Token(ParenL(), _pos);
        </rule>
        <rule pattern="\)">
            return Token(ParenR(), _pos);
        </rule>
        {% id %}
        <rule pattern="\$[0-9a-zA-Z!#%&'*+\-./:<=>@_`\|~\$\^\\?]+">
            return Token(Id(_text.substr(1)), _pos);
        </rule>
        {% string %}
        <rule pattern="\"" push="string" />
        <group name="string">
            <rule pattern="([\x01-\x1f\x7f])">
                throw Exception::Parse("invalid character in string", {_pos.line, _pos.column});
            </rule>
            <rule pattern="$">
                throw Exception::Parse("string not close", {_pos.line, _pos.column});
            </rule>
            <rule pattern="." more />
            <rule pattern="\"" pop>
                return Token(String(_text.substr(0, _text.size() - 1)), _pos);
            </rule>
        </group>
        {% Integer %}
        <rule pattern="[\+\-]?\d[\d_]*">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("integer can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(Integer(_text), _pos);
        </rule>
        <rule pattern="[\+\-]?0x[\da-fA-F][\da-fA-F_]*">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("integer can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(Integer(_text), _pos);
        </rule>
        {% Floating %}
        <rule pattern="[\+\-]?(nan|nan:0x[\da-fA-F][\da-fA-F_]*|inf)">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("floating number can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(Float(_text), _pos);
        </rule>
        <rule pattern="[\+\-]?\d[\d_]*([Ee][\+\-]?\d[\d_]*|\.(\d[\d_]*)?([Ee][\+\-]?\d[\d_]*)?)">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("floating number can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(Float(_text), _pos);
        </rule>
        <rule pattern="[\+\-]?0x[\da-fA-F][\da-fA-F_]*([Pp][\+\-]?\d[\d_]*|\.([\da-fA-F][\da-fA-F_]*)?([Pp][\+\-]?\d[\d_]*)?)">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("floating number can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(Float(_text), _pos);
        </rule>
        {% offset %}
        <rule pattern="offset=\d[\d_]*">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("offset can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(MemOffset(std::stoll(_text.substr(7))), _pos);
        </rule>
        <rule pattern="offset=0x[\da-fA-F][\da-fA-F_]*">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("offset can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(MemOffset(std::stoll(_text.substr(7), nullptr, 16)), _pos);
        </rule>
        {% align %}
        <rule pattern="align=\d[\d_]*">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("align can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(MemAlign(std::stoll(_text.substr(6))), _pos);
        </rule>
        <rule pattern="align=0x[\da-fA-F][\da-fA-F_]*">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("align can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(MemAlign(std::stoll(_text.substr(6), nullptr, 16)), _pos);
        </rule>
        {% keywords %}
        <rule pattern="module">
            return Token(Module(), _pos);
        </rule>    
        <rule pattern="type">
            return Token(Type(), _pos);
        </rule>    
        <rule pattern="import">
            return Token(Import(), _pos);
        </rule>    
        <rule pattern="export">
            return Token(Export(), _pos);
        </rule>    
        <rule pattern="param">
            return Token(Param(), _pos);
        </rule>    
        <rule pattern="result">
            return Token(Result(), _pos);
        </rule>    
        <rule pattern="funcref">
            return Token(Funcref(), _pos);
        </rule>    
        <rule pattern="extern">
            return Token(Extern(), _pos);
        </rule>    
        <rule pattern="externref">
            return Token(Externref(), _pos);
        </rule>    
        <rule pattern="[if](32|64)">
            return Token(NumType(_text), _pos);
        </rule>     
        <rule pattern="func">
            return Token(Func(), _pos);
        </rule>    
        <rule pattern="table">
            return Token(Table(), _pos);
        </rule>    
        <rule pattern="memory">
            return Token(Memory(), _pos);
        </rule>    
        <rule pattern="global">
            return Token(Global(), _pos);
        </rule>    
        <rule pattern="mut">
            return Token(Mut(), _pos);
        </rule>    
        <rule pattern="local">
            return Token(Local(), _pos);
        </rule>    
        <rule pattern="elem">
            return Token(Elem(), _pos);
        </rule>    
        <rule pattern="item">
            return Token(Item(), _pos);
        </rule>    
        <rule pattern="declare">
            return Token(Declare(), _pos);
        </rule>    
        <rule pattern="offset">
            return Token(Offset(), _pos);
        </rule>    
        <rule pattern="data">
            return Token(Data(), _pos);
        </rule>    
        <rule pattern="start">
            return Token(Start(), _pos);
        </rule>
        <rule pattern="then">
            return Token(Then(), _pos);
        </rule>
        <rule pattern="(unreachable|nop|return)">
            if(_text == "unreachable"){
                return Token(ControlInstr(ControlInstr::Unreachable), _pos);
            }else if(_text == "nop"){
                return Token(ControlInstr(ControlInstr::Nop), _pos);
            }else{
                return Token(ControlInstr(ControlInstr::Return), _pos);
            }
        </rule>
        <rule pattern="block">
            return Token(Block(), _pos);
        </rule>
        <rule pattern="end">
            return Token(End(), _pos);
        </rule>
        <rule pattern="loop">
            return Token(Loop(), _pos);
        </rule>
        <rule pattern="if">
            return Token(If(), _pos);
        </rule>
        <rule pattern="else">
            return Token(Else(), _pos);
        </rule>
        <rule pattern="br">
            return Token(Br(), _pos);
        </rule>
        <rule pattern="br_if">
            return Token(Br_if(), _pos);
        </rule>
        <rule pattern="br_table">
            return Token(Br_table(), _pos);
        </rule>
        <rule pattern="call">
            return Token(Call(), _pos);
        </rule>
        <rule pattern="call_indirect">
            return Token(Call_indirect(), _pos);
        </rule>
        <rule pattern="ref\.null">
            return Token(Ref_null(), _pos);
        </rule>
        <rule pattern="ref\.is_null">
            return Token(Ref_is_null(), _pos);
        </rule>
        <rule pattern="ref\.func">
            return Token(Ref_func(), _pos);
        </rule>
        <rule pattern="drop">
            return Token(Drop(), _pos);
        </rule>
        <rule pattern="select">
            return Token(Select(), _pos);
        </rule>
        <rule pattern="((local|global)\.(set|get)|local\.tee)">
            if(_text.starts_with("local")){
                std::string op = _text.substr(6);
                if(op == "get"){
                    return Token(VariableInstr(VariableInstr::LocalGet), _pos);
                }else if(op == "set"){
                    return Token(VariableInstr(VariableInstr::LocalSet), _pos);
                }else{
                    return Token(VariableInstr(VariableInstr::LocalTee), _pos);
                }
            }else{
                std::string op = _text.substr(7);
                if(op == "get"){
                    return Token(VariableInstr(VariableInstr::GlobalGet), _pos);
                }else{
                    return Token(VariableInstr(VariableInstr::GlobalSet), _pos);
                }
            }
        </rule>
        <rule pattern="table\.(get|set|size|grow|fill)">
            if(_text == "table.get"){
                return Token(TableInstr(TableInstr::TableGet), _pos);
            }else if(_text == "table.set"){
                return Token(TableInstr(TableInstr::TableSet), _pos);
            }else if(_text == "table.size"){
                return Token(TableInstr(TableInstr::TableSize), _pos);
            }else if(_text == "table.grow"){
                return Token(TableInstr(TableInstr::TableGrow), _pos);
            }else{
                return Token(TableInstr(TableInstr::TableFill), _pos);
            }
        </rule>
        <rule pattern="table\.copy">
            return Token(Table_copy(), _pos);
        </rule>
        <rule pattern="table\.init">
            return Token(Table_init(), _pos);
        </rule>
        <rule pattern="elem\.drop">
            return Token(Elem_drop(), _pos);
        </rule>
        <rule pattern="memory\.size">
            return Token(Memory_size(), _pos);
        </rule>
        <rule pattern="memory\.grow">
            return Token(Memory_grow(), _pos);
        </rule>
        <rule pattern="memory\.fill">
            return Token(Memory_fill(), _pos);
        </rule>
        <rule pattern="memory\.init">
            return Token(Memory_init(), _pos);
        </rule>
        <rule pattern="memory\.copy">
            return Token(Memory_copy(), _pos);
        </rule>
        <rule pattern="data\.drop">
            return Token(Data_drop(), _pos);
        </rule>
        <rule pattern="i((32|64)\.(load((8|16)_[su])?|store(8|16)?)|64\.(load32_[su]|store32))">
            if(_text.starts_with("i32")){
                std::string op = _text.substr(4);
                if(op.starts_with("load")){
                    op = op.substr(4);
                    if(op.starts_with("8")){
                        op = op.substr(2);
                        if(op == "s"){
                            return Token(MemoryInstr(MemoryInstr::I32Load8_s), _pos);
                        }else{
                            return Token(MemoryInstr(MemoryInstr::I32Load8_u), _pos);
                        }
                    }else if(op.starts_with("16")){
                        op = op.substr(3);
                        if(op == "s"){
                            return Token(MemoryInstr(MemoryInstr::I32Load16_s), _pos);
                        }else{
                            return Token(MemoryInstr(MemoryInstr::I32Load16_u), _pos);
                        }
                    }else{
                        return Token(MemoryInstr(MemoryInstr::I32Load), _pos);
                    }
                }else{
                    op = op.substr(5);
                    if(op.starts_with("8")){
                        return Token(MemoryInstr(MemoryInstr::I32Store8), _pos);
                    }else if(op.starts_with("16")){
                        return Token(MemoryInstr(MemoryInstr::I32Store16), _pos);
                    }else{
                        return Token(MemoryInstr(MemoryInstr::I32Store), _pos);
                    }
                }
            }else{
                std::string op = _text.substr(4);
                if(op.starts_with("load")){
                    op = op.substr(4);
                    if(op.starts_with("8")){
                        op = op.substr(2);
                        if(op == "s"){
                            return Token(MemoryInstr(MemoryInstr::I64Load8_s), _pos);
                        }else{
                            return Token(MemoryInstr(MemoryInstr::I64Load8_u), _pos);
                        }
                    }else if(op.starts_with("16")){
                        op = op.substr(3);
                        if(op == "s"){
                            return Token(MemoryInstr(MemoryInstr::I64Load16_s), _pos);
                        }else{
                            return Token(MemoryInstr(MemoryInstr::I64Load16_u), _pos);
                        }
                    }else if(op.starts_with("32")){
                        op = op.substr(3);
                        if(op == "s"){
                            return Token(MemoryInstr(MemoryInstr::I64Load32_s), _pos);
                        }else{
                            return Token(MemoryInstr(MemoryInstr::I64Load32_u), _pos);
                        }
                    }else{
                        return Token(MemoryInstr(MemoryInstr::I64Load), _pos);
                    }
                }else{
                    op = op.substr(5);
                    if(op.starts_with("8")){
                        return Token(MemoryInstr(MemoryInstr::I64Store8), _pos);
                    }else if(op.starts_with("16")){
                        return Token(MemoryInstr(MemoryInstr::I64Store16), _pos);
                    }else if(op.starts_with("32")){
                        return Token(MemoryInstr(MemoryInstr::I64Store32), _pos);
                    }else{
                        return Token(MemoryInstr(MemoryInstr::I64Store), _pos);
                    }
                }
            }
        </rule>
        <rule pattern="f(32|64)\.(load|store)">
            if(_text == "f32.load"){
                return Token(MemoryInstr(MemoryInstr::F32Load), _pos);
            }else if(_text == "f32.store"){
                return Token(MemoryInstr(MemoryInstr::F32Store), _pos);
            }else if(_text == "f64.load"){
                return Token(MemoryInstr(MemoryInstr::F64Load), _pos);
            }else{
                return Token(MemoryInstr(MemoryInstr::F64Store), _pos);
            }
            return Token(I32_const(), _pos);
        </rule>
        <rule pattern="[if](32|64)\.const">
            if(_text.starts_with("i32")){
                return Token(I32_const(), _pos);
            }else if(_text.starts_with("i64")){
                return Token(I64_const(), _pos);
            }else if(_text.starts_with("f32")){
                return Token(F32_const(), _pos);
            }else{
                return Token(F64_const(), _pos);
            }
        </rule>
        <rule pattern="i(32|64)\.(eqz?|ne|[lg][et]_[su]|c[lt]z|popcnt|add|sub|mul|and|or|xor|shl|rotl|rotr|(div|rem|shr)_[su]">
            if(_text.starts_with("i32")){
                std::string op = _text.substr(4);
                if(op == "eq"){
                    return Token(NumericInstr(NumericInstr::I32Eq), _pos);
                }else if(op == "eqz"){
                    return Token(NumericInstr(NumericInstr::I32Eqz), _pos);
                }else if(op == "ne"){
                    return Token(NumericInstr(NumericInstr::I32Ne), _pos);
                }else if(op == "le_s"){
                    return Token(NumericInstr(NumericInstr::I32Le_s), _pos);
                }else if(op == "lt_s"){
                    return Token(NumericInstr(NumericInstr::I32Lt_s), _pos);
                }else if(op == "ge_s"){
                    return Token(NumericInstr(NumericInstr::I32Ge_s), _pos);
                }else if(op == "gt_s"){
                    return Token(NumericInstr(NumericInstr::I32Gt_s), _pos);
                }else if(op == "le_u"){
                    return Token(NumericInstr(NumericInstr::I32Le_u), _pos);
                }else if(op == "lt_u"){
                    return Token(NumericInstr(NumericInstr::I32Lt_u), _pos);
                }else if(op == "ge_u"){
                    return Token(NumericInstr(NumericInstr::I32Ge_u), _pos);
                }else if(op == "gt_u"){
                    return Token(NumericInstr(NumericInstr::I32Gt_u), _pos);
                }else if(op == "clz"){
                    return Token(NumericInstr(NumericInstr::I32Clz), _pos);
                }else if(op == "ctz"){
                    return Token(NumericInstr(NumericInstr::I32Ctz), _pos);
                }else if(op == "popcnt"){
                    return Token(NumericInstr(NumericInstr::I32Popcnt), _pos);
                }else if(op == "add"){
                    return Token(NumericInstr(NumericInstr::I32Add), _pos);
                }else if(op == "sub"){
                    return Token(NumericInstr(NumericInstr::I32Sub), _pos);
                }else if(op == "mul"){
                    return Token(NumericInstr(NumericInstr::I32Mul), _pos);
                }else if(op == "and"){
                    return Token(NumericInstr(NumericInstr::I32And), _pos);
                }else if(op == "or"){
                    return Token(NumericInstr(NumericInstr::I32Or), _pos);
                }else if(op == "xor"){
                    return Token(NumericInstr(NumericInstr::I32Xor), _pos);
                }else if(op == "shl"){
                    return Token(NumericInstr(NumericInstr::I32Shl), _pos);
                }else if(op == "rotl"){
                    return Token(NumericInstr(NumericInstr::I32Rotl), _pos);
                }else if(op == "rotr"){
                    return Token(NumericInstr(NumericInstr::I32Rotr), _pos);
                }else if(op == "div_s"){
                    return Token(NumericInstr(NumericInstr::I32Div_s), _pos);
                }else if(op == "div_u"){
                    return Token(NumericInstr(NumericInstr::I32Div_u), _pos);
                }else if(op == "rem_s"){
                    return Token(NumericInstr(NumericInstr::I32Rem_s), _pos);
                }else if(op == "rem_u"){
                    return Token(NumericInstr(NumericInstr::I32Rem_u), _pos);
                }else if(op == "shr_s"){
                    return Token(NumericInstr(NumericInstr::I32Shr_s), _pos);
                }else{
                    return Token(NumericInstr(NumericInstr::I32Shr_u), _pos);
                }
            }else{
                std::string op = _text.substr(4);
                if(op == "eq"){
                    return Token(NumericInstr(NumericInstr::I64Eq), _pos);
                }else if(op == "eqz"){
                    return Token(NumericInstr(NumericInstr::I64Eqz), _pos);
                }else if(op == "ne"){
                    return Token(NumericInstr(NumericInstr::I64Ne), _pos);
                }else if(op == "le_s"){
                    return Token(NumericInstr(NumericInstr::I64Le_s), _pos);
                }else if(op == "lt_s"){
                    return Token(NumericInstr(NumericInstr::I64Lt_s), _pos);
                }else if(op == "ge_s"){
                    return Token(NumericInstr(NumericInstr::I64Ge_s), _pos);
                }else if(op == "gt_s"){
                    return Token(NumericInstr(NumericInstr::I64Gt_s), _pos);
                }else if(op == "le_u"){
                    return Token(NumericInstr(NumericInstr::I64Le_u), _pos);
                }else if(op == "lt_u"){
                    return Token(NumericInstr(NumericInstr::I64Lt_u), _pos);
                }else if(op == "ge_u"){
                    return Token(NumericInstr(NumericInstr::I64Ge_u), _pos);
                }else if(op == "gt_u"){
                    return Token(NumericInstr(NumericInstr::I64Gt_u), _pos);
                }else if(op == "clz"){
                    return Token(NumericInstr(NumericInstr::I64Clz), _pos);
                }else if(op == "ctz"){
                    return Token(NumericInstr(NumericInstr::I64Ctz), _pos);
                }else if(op == "popcnt"){
                    return Token(NumericInstr(NumericInstr::I64Popcnt), _pos);
                }else if(op == "add"){
                    return Token(NumericInstr(NumericInstr::I64Add), _pos);
                }else if(op == "sub"){
                    return Token(NumericInstr(NumericInstr::I64Sub), _pos);
                }else if(op == "mul"){
                    return Token(NumericInstr(NumericInstr::I64Mul), _pos);
                }else if(op == "and"){
                    return Token(NumericInstr(NumericInstr::I64And), _pos);
                }else if(op == "or"){
                    return Token(NumericInstr(NumericInstr::I64Or), _pos);
                }else if(op == "xor"){
                    return Token(NumericInstr(NumericInstr::I64Xor), _pos);
                }else if(op == "shl"){
                    return Token(NumericInstr(NumericInstr::I64Shl), _pos);
                }else if(op == "rotl"){
                    return Token(NumericInstr(NumericInstr::I64Rotl), _pos);
                }else if(op == "rotr"){
                    return Token(NumericInstr(NumericInstr::I64Rotr), _pos);
                }else if(op == "div_s"){
                    return Token(NumericInstr(NumericInstr::I64Div_s), _pos);
                }else if(op == "div_u"){
                    return Token(NumericInstr(NumericInstr::I64Div_u), _pos);
                }else if(op == "rem_s"){
                    return Token(NumericInstr(NumericInstr::I64Rem_s), _pos);
                }else if(op == "rem_u"){
                    return Token(NumericInstr(NumericInstr::I64Rem_u), _pos);
                }else if(op == "shr_s"){
                    return Token(NumericInstr(NumericInstr::I64Shr_s), _pos);
                }else{
                    return Token(NumericInstr(NumericInstr::I64Shr_u), _pos);
                }
            }
        </rule>
        <rule pattern="f(32|64)\.(eq|ne|[lg][et]|abs|neg|ceil|floor|trunc|nearest|sqrt|add|sub|mul|div|min|max|copysign)">
            if(_text.starts_with("f32")){
                std::string op = _text.substr(4);
                if(op == "eq"){
                    return Token(NumericInstr(NumericInstr::F32Eq), _pos);
                }else if(op == "ne"){
                    return Token(NumericInstr(NumericInstr::F32Ne), _pos);
                }else if(op == "le"){
                    return Token(NumericInstr(NumericInstr::F32Le), _pos);
                }else if(op == "lt"){
                    return Token(NumericInstr(NumericInstr::F32Lt), _pos);
                }else if(op == "ge"){
                    return Token(NumericInstr(NumericInstr::F32Ge), _pos);
                }else if(op == "gt"){
                    return Token(NumericInstr(NumericInstr::F32Gt), _pos);
                }else if(op == "abs"){
                    return Token(NumericInstr(NumericInstr::F32Abs), _pos);
                }else if(op == "neg"){
                    return Token(NumericInstr(NumericInstr::F32Neg), _pos);
                }else if(op == "ceil"){
                    return Token(NumericInstr(NumericInstr::F32Ceil), _pos);
                }else if(op == "floor"){
                    return Token(NumericInstr(NumericInstr::F32Floor), _pos);
                }else if(op == "trunc"){
                    return Token(NumericInstr(NumericInstr::F32Trunc), _pos);
                }else if(op == "nearest"){
                    return Token(NumericInstr(NumericInstr::F32Nearest), _pos);
                }else if(op == "sqrt"){
                    return Token(NumericInstr(NumericInstr::F32Sqrt), _pos);
                }else if(op == "add"){
                    return Token(NumericInstr(NumericInstr::F32Add), _pos);
                }else if(op == "sub"){
                    return Token(NumericInstr(NumericInstr::F32Sub), _pos);
                }else if(op == "mul"){
                    return Token(NumericInstr(NumericInstr::F32Mul), _pos);
                }else if(op == "div"){
                    return Token(NumericInstr(NumericInstr::F32Div), _pos);
                }else if(op == "min"){
                    return Token(NumericInstr(NumericInstr::F32Min), _pos);
                }else if(op == "max"){
                    return Token(NumericInstr(NumericInstr::F32Max), _pos);
                }else{
                    return Token(NumericInstr(NumericInstr::F32Copysign), _pos);
                }
            }else{
                std::string op = _text.substr(4);
                if(op == "eq"){
                    return Token(NumericInstr(NumericInstr::F64Eq), _pos);
                }else if(op == "ne"){
                    return Token(NumericInstr(NumericInstr::F64Ne), _pos);
                }else if(op == "le"){
                    return Token(NumericInstr(NumericInstr::F64Le), _pos);
                }else if(op == "lt"){
                    return Token(NumericInstr(NumericInstr::F64Lt), _pos);
                }else if(op == "ge"){
                    return Token(NumericInstr(NumericInstr::F64Ge), _pos);
                }else if(op == "gt"){
                    return Token(NumericInstr(NumericInstr::F64Gt), _pos);
                }else if(op == "abs"){
                    return Token(NumericInstr(NumericInstr::F64Abs), _pos);
                }else if(op == "neg"){
                    return Token(NumericInstr(NumericInstr::F64Neg), _pos);
                }else if(op == "ceil"){
                    return Token(NumericInstr(NumericInstr::F64Ceil), _pos);
                }else if(op == "floor"){
                    return Token(NumericInstr(NumericInstr::F64Floor), _pos);
                }else if(op == "trunc"){
                    return Token(NumericInstr(NumericInstr::F64Trunc), _pos);
                }else if(op == "nearest"){
                    return Token(NumericInstr(NumericInstr::F64Nearest), _pos);
                }else if(op == "sqrt"){
                    return Token(NumericInstr(NumericInstr::F64Sqrt), _pos);
                }else if(op == "add"){
                    return Token(NumericInstr(NumericInstr::F64Add), _pos);
                }else if(op == "sub"){
                    return Token(NumericInstr(NumericInstr::F64Sub), _pos);
                }else if(op == "mul"){
                    return Token(NumericInstr(NumericInstr::F64Mul), _pos);
                }else if(op == "div"){
                    return Token(NumericInstr(NumericInstr::F64Div), _pos);
                }else if(op == "min"){
                    return Token(NumericInstr(NumericInstr::F64Min), _pos);
                }else if(op == "max"){
                    return Token(NumericInstr(NumericInstr::F64Max), _pos);
                }else{
                    return Token(NumericInstr(NumericInstr::F64Copysign), _pos);
                }
            }
        </rule>
{% 
        <rule pattern="i32\.wrap_i64">
            return Token(I32_wrap_i64(), _pos);
        </rule>
        <rule pattern="i32\.trunc_s_f32">
            return Token(I32_trunc_s_f32(), _pos);
        </rule>
        <rule pattern="i32\.trunc_u_f32">
            return Token(I32_trunc_u_f32(), _pos);
        </rule>
        <rule pattern="i32\.trunc_s_f64">
            return Token(I32_trunc_s_f64(), _pos);
        </rule>
        <rule pattern="i32\.trunc_u_f64">
            return Token(I32_trunc_u_f64(), _pos);
        </rule>
        <rule pattern="i64\.extend_s_i32">
            return Token(I64_extend_s_i32(), _pos);
        </rule>
        <rule pattern="i64\.extend_u_i32">
            return Token(I64_extend_u_i32(), _pos);
        </rule>
        <rule pattern="i64\.trunc_s_f32">
            return Token(I64_trunc_s_f32(), _pos);
        </rule>
        <rule pattern="i64\.trunc_u_f32">
            return Token(I64_trunc_u_f32(), _pos);
        </rule>
        <rule pattern="i64\.trunc_s_f64">
            return Token(I64_trunc_s_f64(), _pos);
        </rule>
        <rule pattern="i64\.trunc_u_f64">
            return Token(I64_trunc_u_f64(), _pos);
        </rule>
        <rule pattern="f32\.convert_s_i32">
            return Token(F32_convert_s_i32(), _pos);
        </rule>
        <rule pattern="f32\.convert_u_i32">
            return Token(F32_convert_u_i32(), _pos);
        </rule>
        <rule pattern="f32\.convert_s_i64">
            return Token(F32_convert_s_i64(), _pos);
        </rule>
        <rule pattern="f32\.convert_u_i64">
            return Token(F32_convert_u_i64(), _pos);
        </rule>
        <rule pattern="f32\.demote_f64">
            return Token(F32_demote_f64(), _pos);
        </rule>
        <rule pattern="f64\.convert_s_i32">
            return Token(F64_convert_s_i32(), _pos);
        </rule>
        <rule pattern="f64\.convert_u_i32">
            return Token(F64_convert_u_i32(), _pos);
        </rule>
        <rule pattern="f64\.convert_s_i64">
            return Token(F64_convert_s_i64(), _pos);
        </rule>
        <rule pattern="f64\.convert_u_i64">
            return Token(F64_convert_u_i64(), _pos);
        </rule>
        <rule pattern="f64\.promote_f32">
            return Token(F64_promote_f32(), _pos);
        </rule>
        <rule pattern="i32\.reinterpret_f32">
            return Token(I32_reinterpret_f32(), _pos);
        </rule>
        <rule pattern="i64\.reinterpret_f64">
            return Token(I64_reinterpret_f64(), _pos);
        </rule>
        <rule pattern="f32\.reinterpret_i32">
            return Token(F32_reinterpret_i32(), _pos);
        </rule>
        <rule pattern="f64\.reinterpret_i64">
            return Token(F64_reinterpret_i64(), _pos);
        </rule>
        <rule pattern="i32\.extend8_s">
            return Token(I32_extend8_s(), _pos);
        </rule>
        <rule pattern="i32\.extend16_s">
            return Token(I32_extend16_s(), _pos);
        </rule>
        <rule pattern="i64\.extend8_s">
            return Token(I64_extend8_s(), _pos);
        </rule>
        <rule pattern="i64\.extend16_s">
            return Token(I64_extend16_s(), _pos);
        </rule>
        <rule pattern="i64\.extend32_s">
            return Token(I64_extend32_s(), _pos);
        </rule>
        <rule pattern="i32\.trunc_sat_f32_s">
            return Token(I32_trunc_sat_f32_s(), _pos);
        </rule>
        <rule pattern="i32\.trunc_sat_f32_u">
            return Token(I32_trunc_sat_f32_u(), _pos);
        </rule>
        <rule pattern="i32\.trunc_sat_f64_s">
            return Token(I32_trunc_sat_f64_s(), _pos);
        </rule>
        <rule pattern="i32\.trunc_sat_f64_u">
            return Token(I32_trunc_sat_f64_u(), _pos);
        </rule>
        <rule pattern="i64\.trunc_sat_f32_s">
            return Token(I64_trunc_sat_f32_s(), _pos);
        </rule>
        <rule pattern="i64\.trunc_sat_f64_u">
            return Token(I64_trunc_sat_f64_u(), _pos);
        </rule>
        <rule pattern="i64\.trunc_sat_f64_s">
            return Token(I64_trunc_sat_f64_s(), _pos);
        </rule>
        <rule pattern="i64\.trunc_sat_f32_u">
            return Token(I64_trunc_sat_f32_u(), _pos);
        </rule> %}
    </lexer>
</pxml>