/** generated by ParGen **/
#include "Lexer.hpp"


namespace WasmVM {

using namespace Tokens;

Lexer::Lexer(std::filesystem::path path, std::istream& stream) :
  stream(stream), state(16)
{
    current = fetch();
    pos.path = path;
}

Lexer::Chars::Chars(std::initializer_list<Chars::char_t> init) : min(init.begin()[0]){
    if(init.size() == 1){
        max = init.begin()[0];
    }else{
        max = init.begin()[1];
    }
}

bool Lexer::Chars::operator<(const Chars& rhs) const {
    return (min < rhs.min) && (max < rhs.min);
}

Lexer::Chars::char_t Lexer::fetch(){
    std::string line_end = "";
    Chars::char_t res = stream.get();
    if(res != std::istream::traits_type::eof()){
        line_end += res;
        text += res;
        if(line_end.size() > 2){
            line_end = line_end.substr(line_end.size() - 2);
        }
        if(text.ends_with("\n")){
            cur.line += 1;
            cur.column = 0;
        }else{
            cur.column += 1;
        }
    }
    return res;
}

std::vector<Lexer::State> Lexer::states = {
    {{{-1},1}, {{0},2}, {{40},3}, {{59},4}, }, // S0
    {}, // S1
    {}, // S2
    {{{59},5}, }, // S3
    {{{41},6}, }, // S4
    {}, // S5
    {}, // S6
    {{{-1},8}, {{0},9}, {{10},10}, }, // S7
    {}, // S8
    {}, // S9
    {}, // S10
    {{{-1},12}, {{0},13}, {{1,31},14}, {{34},15}, {{127},14}, }, // S11
    {}, // S12
    {}, // S13
    {}, // S14
    {}, // S15
    {{{-1},17}, {{9},18}, {{10},19}, {{13},20}, {{32},21}, {{34},22}, {{36},23}, {{40},24}, {{41},25}, {{43},26}, {{45},26}, {{48},27}, {{49,57},28}, {{59},29}, {{97},30}, {{98},31}, {{99},32}, {{100},33}, {{101},34}, {{102},35}, {{103},36}, {{105},37}, {{108},38}, {{109},39}, {{110},40}, {{111},41}, {{112},42}, {{114},43}, {{115},44}, {{116},45}, {{117},46}, }, // S16
    {}, // S17
    {}, // S18
    {}, // S19
    {}, // S20
    {}, // S21
    {}, // S22
    {{{33},47}, {{35,39},47}, {{42,43},47}, {{45,58},47}, {{60,90},47}, {{92},47}, {{94,122},47}, {{124},47}, {{126},47}, }, // S23
    {{{59},48}, }, // S24
    {}, // S25
    {{{48},27}, {{49,57},28}, {{105},49}, {{110},50}, }, // S26
    {{{46},51}, {{48,57},52}, {{69},53}, {{95},52}, {{101},53}, {{120},54}, }, // S27
    {{{46},51}, {{48,57},52}, {{69},53}, {{95},52}, {{101},53}, }, // S28
    {{{59},55}, }, // S29
    {{{108},56}, }, // S30
    {{{108},57}, {{114},58}, }, // S31
    {{{97},59}, }, // S32
    {{{97},60}, {{101},61}, {{114},62}, }, // S33
    {{{108},63}, {{110},64}, {{120},65}, }, // S34
    {{{51},66}, {{54},67}, {{117},68}, }, // S35
    {{{108},69}, }, // S36
    {{{51},70}, {{54},71}, {{102},72}, {{109},73}, {{110},74}, {{116},75}, }, // S37
    {{{111},76}, }, // S38
    {{{101},77}, {{111},78}, {{117},79}, }, // S39
    {{{97},80}, {{111},81}, }, // S40
    {{{102},82}, }, // S41
    {{{97},83}, }, // S42
    {{{101},84}, }, // S43
    {{{101},85}, {{116},86}, }, // S44
    {{{97},87}, {{104},88}, {{121},89}, }, // S45
    {{{110},90}, }, // S46
    {{{33},47}, {{35,39},47}, {{42,43},47}, {{45,58},47}, {{60,90},47}, {{92},47}, {{94,122},47}, {{124},47}, {{126},47}, }, // S47
    {}, // S48
    {{{110},74}, }, // S49
    {{{97},80}, }, // S50
    {{{48,57},91}, {{69},92}, {{95},93}, {{101},92}, }, // S51
    {{{46},51}, {{48,57},52}, {{69},53}, {{95},52}, {{101},53}, }, // S52
    {{{43},94}, {{45},94}, {{48,57},95}, }, // S53
    {{{48,57},96}, {{65,70},96}, {{97,102},96}, }, // S54
    {}, // S55
    {{{105},97}, }, // S56
    {{{111},98}, }, // S57
    {{{95},99}, }, // S58
    {{{108},100}, }, // S59
    {{{116},101}, }, // S60
    {{{99},102}, }, // S61
    {{{111},103}, }, // S62
    {{{101},104}, {{115},105}, }, // S63
    {{{100},106}, }, // S64
    {{{112},107}, {{116},108}, }, // S65
    {{{50},109}, }, // S66
    {{{52},110}, }, // S67
    {{{110},111}, }, // S68
    {{{111},112}, }, // S69
    {{{50},113}, }, // S70
    {{{52},114}, }, // S71
    {}, // S72
    {{{112},115}, }, // S73
    {{{102},116}, }, // S74
    {{{101},117}, }, // S75
    {{{99},118}, {{111},119}, }, // S76
    {{{109},120}, }, // S77
    {{{100},121}, }, // S78
    {{{116},122}, }, // S79
    {{{110},123}, }, // S80
    {{{112},124}, }, // S81
    {{{102},125}, }, // S82
    {{{114},126}, }, // S83
    {{{102},127}, {{115},128}, {{116},129}, }, // S84
    {{{108},130}, }, // S85
    {{{97},131}, }, // S86
    {{{98},132}, }, // S87
    {{{101},133}, }, // S88
    {{{112},134}, }, // S89
    {{{114},135}, }, // S90
    {{{48,57},93}, {{69},92}, {{95},93}, {{101},92}, }, // S91
    {{{43},136}, {{45},136}, {{48,57},137}, }, // S92
    {{{48,57},93}, {{69},92}, {{95},93}, {{101},92}, }, // S93
    {{{48,57},95}, }, // S94
    {{{48,57},138}, {{95},138}, }, // S95
    {{{46},139}, {{48,57},140}, {{65,70},140}, {{80},141}, {{95},140}, {{97,102},140}, {{112},141}, }, // S96
    {{{103},142}, }, // S97
    {{{99},143}, }, // S98
    {{{105},144}, {{116},145}, }, // S99
    {{{108},146}, }, // S100
    {{{97},147}, }, // S101
    {{{108},148}, }, // S102
    {{{112},149}, }, // S103
    {{{109},150}, }, // S104
    {{{101},151}, }, // S105
    {}, // S106
    {{{111},152}, }, // S107
    {{{101},153}, }, // S108
    {{{46},154}, }, // S109
    {{{46},154}, }, // S110
    {{{99},155}, }, // S111
    {{{98},156}, }, // S112
    {{{46},157}, }, // S113
    {{{46},158}, }, // S114
    {{{111},159}, }, // S115
    {}, // S116
    {{{109},160}, }, // S117
    {{{97},161}, }, // S118
    {{{112},162}, }, // S119
    {{{111},163}, }, // S120
    {{{117},164}, }, // S121
    {}, // S122
    {{{58},165}, }, // S123
    {}, // S124
    {{{115},166}, }, // S125
    {{{97},167}, }, // S126
    {{{46},168}, }, // S127
    {{{117},169}, }, // S128
    {{{117},170}, }, // S129
    {{{101},171}, }, // S130
    {{{114},172}, }, // S131
    {{{108},173}, }, // S132
    {{{110},174}, }, // S133
    {{{101},175}, }, // S134
    {{{101},176}, }, // S135
    {{{48,57},137}, }, // S136
    {{{48,57},177}, {{95},177}, }, // S137
    {{{48,57},138}, {{95},138}, }, // S138
    {{{48,57},178}, {{65,70},178}, {{80},179}, {{95},180}, {{97,102},178}, {{112},179}, }, // S139
    {{{46},139}, {{48,57},140}, {{65,70},140}, {{80},141}, {{95},140}, {{97,102},140}, {{112},141}, }, // S140
    {{{43},181}, {{45},181}, {{48,57},182}, }, // S141
    {{{110},183}, }, // S142
    {{{107},184}, }, // S143
    {{{102},185}, }, // S144
    {{{97},186}, }, // S145
    {{{95},187}, }, // S146
    {{{46},188}, }, // S147
    {{{97},189}, }, // S148
    {}, // S149
    {{{46},190}, }, // S150
    {}, // S151
    {{{114},191}, }, // S152
    {{{114},192}, }, // S153
    {{{97},193}, {{99},194}, {{100},195}, {{101},196}, {{102},197}, {{103},198}, {{108},199}, {{109},200}, {{110},201}, {{115},202}, {{116},203}, }, // S154
    {{{114},204}, }, // S155
    {{{97},205}, }, // S156
    {{{97},206}, {{99},207}, {{100},208}, {{101},209}, {{103},210}, {{108},211}, {{109},212}, {{110},213}, {{111},214}, {{112},215}, {{114},216}, {{115},217}, {{120},218}, }, // S157
    {{{97},206}, {{99},207}, {{100},208}, {{101},209}, {{103},210}, {{108},219}, {{109},212}, {{110},213}, {{111},214}, {{112},215}, {{114},216}, {{115},220}, {{120},218}, }, // S158
    {{{114},221}, }, // S159
    {}, // S160
    {{{108},222}, }, // S161
    {}, // S162
    {{{114},223}, }, // S163
    {{{108},224}, }, // S164
    {{{48},225}, }, // S165
    {{{101},226}, }, // S166
    {{{109},227}, }, // S167
    {{{102},228}, {{105},229}, {{110},230}, }, // S168
    {{{108},231}, }, // S169
    {{{114},232}, }, // S170
    {{{99},233}, }, // S171
    {{{116},234}, }, // S172
    {{{101},235}, }, // S173
    {}, // S174
    {}, // S175
    {{{97},236}, }, // S176
    {{{48,57},177}, {{95},177}, }, // S177
    {{{48,57},180}, {{65,70},180}, {{80},179}, {{95},180}, {{97,102},180}, {{112},179}, }, // S178
    {{{43},237}, {{45},237}, {{48,57},238}, }, // S179
    {{{48,57},180}, {{65,70},180}, {{80},179}, {{95},180}, {{97,102},180}, {{112},179}, }, // S180
    {{{48,57},182}, }, // S181
    {{{48,57},239}, {{95},239}, }, // S182
    {{{61},240}, }, // S183
    {}, // S184
    {}, // S185
    {{{98},241}, }, // S186
    {{{105},242}, }, // S187
    {{{100},243}, }, // S188
    {{{114},244}, }, // S189
    {{{100},245}, }, // S190
    {{{116},246}, }, // S191
    {{{110},247}, }, // S192
    {{{98},248}, {{100},249}, }, // S193
    {{{101},250}, {{111},251}, }, // S194
    {{{105},252}, }, // S195
    {{{113},253}, }, // S196
    {{{108},254}, }, // S197
    {{{101},255}, {{116},255}, }, // S198
    {{{101},255}, {{111},256}, {{116},255}, }, // S199
    {{{97},257}, {{105},258}, {{117},259}, }, // S200
    {{{101},260}, }, // S201
    {{{113},261}, {{116},262}, {{117},263}, }, // S202
    {{{114},264}, }, // S203
    {{{101},265}, }, // S204
    {{{108},266}, }, // S205
    {{{100},267}, {{110},268}, }, // S206
    {{{108},269}, {{111},270}, {{116},269}, }, // S207
    {{{105},271}, }, // S208
    {{{113},272}, }, // S209
    {{{101},273}, {{116},273}, }, // S210
    {{{101},273}, {{111},274}, {{116},273}, }, // S211
    {{{117},275}, }, // S212
    {{{101},276}, }, // S213
    {{{114},277}, }, // S214
    {{{111},278}, }, // S215
    {{{101},279}, {{111},280}, }, // S216
    {{{104},281}, {{116},282}, {{117},283}, }, // S217
    {{{111},284}, }, // S218
    {{{101},273}, {{111},285}, {{116},273}, }, // S219
    {{{104},281}, {{116},286}, {{117},283}, }, // S220
    {{{116},287}, }, // S221
    {{{46},288}, }, // S222
    {{{121},289}, }, // S223
    {{{101},290}, }, // S224
    {{{120},291}, }, // S225
    {{{116},292}, }, // S226
    {}, // S227
    {{{117},293}, }, // S228
    {{{115},294}, }, // S229
    {{{117},295}, }, // S230
    {{{116},296}, }, // S231
    {{{110},297}, }, // S232
    {{{116},298}, }, // S233
    {}, // S234
    {{{46},299}, }, // S235
    {{{99},300}, }, // S236
    {{{48,57},238}, }, // S237
    {{{48,57},301}, {{95},301}, }, // S238
    {{{48,57},239}, {{95},239}, }, // S239
    {{{48},302}, {{49,57},303}, }, // S240
    {{{108},304}, }, // S241
    {{{110},305}, }, // S242
    {{{114},306}, }, // S243
    {{{101},307}, }, // S244
    {{{114},308}, }, // S245
    {}, // S246
    {{{114},309}, }, // S247
    {{{115},310}, }, // S248
    {{{100},311}, }, // S249
    {{{105},312}, }, // S250
    {{{110},313}, {{112},314}, }, // S251
    {{{118},315}, }, // S252
    {}, // S253
    {{{111},316}, }, // S254
    {}, // S255
    {{{97},317}, }, // S256
    {{{120},318}, }, // S257
    {{{110},319}, }, // S258
    {{{108},320}, }, // S259
    {{{97},321}, {{103},322}, }, // S260
    {{{114},323}, }, // S261
    {{{111},324}, }, // S262
    {{{98},325}, }, // S263
    {{{117},326}, }, // S264
    {{{102},327}, }, // S265
    {{{46},328}, }, // S266
    {{{100},329}, }, // S267
    {{{100},330}, }, // S268
    {{{122},331}, }, // S269
    {{{110},313}, }, // S270
    {{{118},332}, }, // S271
    {{{122},333}, }, // S272
    {{{95},334}, }, // S273
    {{{97},335}, }, // S274
    {{{108},336}, }, // S275
    {}, // S276
    {}, // S277
    {{{112},337}, }, // S278
    {{{109},338}, }, // S279
    {{{116},339}, }, // S280
    {{{108},340}, {{114},341}, }, // S281
    {{{111},342}, }, // S282
    {{{98},343}, }, // S283
    {{{114},344}, }, // S284
    {{{97},345}, }, // S285
    {{{111},346}, }, // S286
    {}, // S287
    {{{103},347}, {{115},348}, {{116},349}, }, // S288
    {{{46},350}, }, // S289
    {}, // S290
    {{{48,57},351}, {{65,70},351}, {{97,102},351}, }, // S291
    {{{61},352}, }, // S292
    {{{110},353}, }, // S293
    {{{95},354}, }, // S294
    {{{108},355}, }, // S295
    {}, // S296
    {}, // S297
    {}, // S298
    {{{99},356}, {{102},357}, {{103},358}, {{105},359}, {{115},360}, }, // S299
    {{{104},361}, }, // S300
    {{{48,57},301}, {{95},301}, }, // S301
    {{{48,57},362}, {{95},362}, {{120},363}, }, // S302
    {{{48,57},362}, {{95},362}, }, // S303
    {{{101},364}, }, // S304
    {{{100},365}, }, // S305
    {{{111},366}, }, // S306
    {}, // S307
    {{{111},367}, }, // S308
    {{{101},368}, }, // S309
    {}, // S310
    {}, // S311
    {{{108},369}, }, // S312
    {{{115},370}, }, // S313
    {{{121},371}, }, // S314
    {}, // S315
    {{{111},372}, }, // S316
    {{{100},373}, }, // S317
    {}, // S318
    {}, // S319
    {}, // S320
    {{{114},374}, }, // S321
    {}, // S322
    {{{116},375}, }, // S323
    {{{114},376}, }, // S324
    {}, // S325
    {{{110},377}, }, // S326
    {}, // S327
    {{{103},347}, {{115},348}, }, // S328
    {}, // S329
    {}, // S330
    {}, // S331
    {{{95},378}, }, // S332
    {}, // S333
    {{{115},379}, {{117},379}, }, // S334
    {{{100},380}, }, // S335
    {}, // S336
    {{{99},381}, }, // S337
    {{{95},378}, }, // S338
    {{{108},382}, {{114},383}, }, // S339
    {}, // S340
    {{{95},378}, }, // S341
    {{{114},384}, }, // S342
    {}, // S343
    {}, // S344
    {{{100},385}, }, // S345
    {{{114},386}, }, // S346
    {{{101},387}, }, // S347
    {{{101},388}, }, // S348
    {{{101},389}, }, // S349
    {{{99},390}, {{102},391}, {{103},392}, {{105},393}, {{115},394}, }, // S350
    {{{48,57},395}, {{65,70},395}, {{95},395}, {{97,102},395}, }, // S351
    {{{48},396}, {{49,57},397}, }, // S352
    {{{99},398}, }, // S353
    {{{110},399}, }, // S354
    {{{108},400}, }, // S355
    {{{111},401}, }, // S356
    {{{105},402}, }, // S357
    {{{101},403}, {{114},404}, }, // S358
    {{{110},405}, }, // S359
    {{{101},406}, {{105},407}, }, // S360
    {{{97},408}, }, // S361
    {{{48,57},362}, {{95},362}, }, // S362
    {{{48,57},409}, {{65,70},409}, {{97,102},409}, }, // S363
    {}, // S364
    {{{105},410}, }, // S365
    {{{112},411}, }, // S366
    {{{112},412}, }, // S367
    {{{102},413}, }, // S368
    {}, // S369
    {{{116},414}, }, // S370
    {{{115},415}, }, // S371
    {{{114},416}, }, // S372
    {}, // S373
    {{{101},417}, }, // S374
    {}, // S375
    {{{101},418}, }, // S376
    {{{99},419}, }, // S377
    {{{115},420}, {{117},420}, }, // S378
    {}, // S379
    {{{49},421}, {{56},422}, }, // S380
    {{{110},423}, }, // S381
    {}, // S382
    {}, // S383
    {{{101},424}, }, // S384
    {{{49},421}, {{51},425}, {{56},422}, }, // S385
    {{{101},426}, }, // S386
    {{{116},427}, }, // S387
    {{{116},428}, }, // S388
    {{{101},429}, }, // S389
    {{{111},430}, }, // S390
    {{{105},431}, }, // S391
    {{{114},432}, }, // S392
    {{{110},433}, }, // S393
    {{{105},434}, }, // S394
    {{{48,57},395}, {{65,70},395}, {{95},395}, {{97,102},395}, }, // S395
    {{{48,57},435}, {{95},435}, {{120},436}, }, // S396
    {{{48,57},435}, {{95},435}, }, // S397
    {}, // S398
    {{{117},437}, }, // S399
    {}, // S400
    {{{112},438}, }, // S401
    {{{108},439}, }, // S402
    {{{116},440}, }, // S403
    {{{111},441}, }, // S404
    {{{105},442}, }, // S405
    {{{116},443}, }, // S406
    {{{122},444}, }, // S407
    {{{98},445}, }, // S408
    {{{48,57},446}, {{65,70},446}, {{95},446}, {{97,102},446}, }, // S409
    {{{114},447}, }, // S410
    {}, // S411
    {}, // S412
    {}, // S413
    {}, // S414
    {{{105},448}, }, // S415
    {}, // S416
    {{{115},449}, }, // S417
    {}, // S418
    {}, // S419
    {}, // S420
    {{{54},450}, }, // S421
    {{{95},451}, }, // S422
    {{{116},452}, }, // S423
    {{{49},453}, {{56},454}, }, // S424
    {{{50},455}, }, // S425
    {{{49},453}, {{51},456}, {{56},454}, }, // S426
    {}, // S427
    {}, // S428
    {}, // S429
    {{{112},457}, }, // S430
    {{{108},458}, }, // S431
    {{{111},459}, }, // S432
    {{{105},460}, }, // S433
    {{{122},461}, }, // S434
    {{{48,57},435}, {{95},435}, }, // S435
    {{{48,57},462}, {{65,70},462}, {{97,102},462}, }, // S436
    {{{108},463}, }, // S437
    {{{121},464}, }, // S438
    {{{108},465}, }, // S439
    {}, // S440
    {{{119},466}, }, // S441
    {{{116},467}, }, // S442
    {}, // S443
    {{{101},468}, }, // S444
    {{{108},469}, }, // S445
    {{{48,57},446}, {{65,70},446}, {{95},446}, {{97,102},446}, }, // S446
    {{{101},470}, }, // S447
    {{{103},471}, }, // S448
    {{{116},472}, }, // S449
    {{{95},451}, }, // S450
    {{{115},473}, {{117},473}, }, // S451
    {}, // S452
    {{{54},474}, }, // S453
    {}, // S454
    {{{95},475}, }, // S455
    {{{50},476}, }, // S456
    {{{121},477}, }, // S457
    {{{108},478}, }, // S458
    {{{119},479}, }, // S459
    {{{116},480}, }, // S460
    {{{101},481}, }, // S461
    {{{48,57},482}, {{65,70},482}, {{95},482}, {{97,102},482}, }, // S462
    {{{108},483}, }, // S463
    {}, // S464
    {}, // S465
    {}, // S466
    {}, // S467
    {}, // S468
    {{{101},484}, }, // S469
    {{{99},485}, }, // S470
    {{{110},486}, }, // S471
    {}, // S472
    {}, // S473
    {}, // S474
    {{{115},487}, {{117},487}, }, // S475
    {}, // S476
    {}, // S477
    {}, // S478
    {}, // S479
    {}, // S480
    {}, // S481
    {{{48,57},482}, {{65,70},482}, {{95},482}, {{97,102},482}, }, // S482
    {}, // S483
    {}, // S484
    {{{116},488}, }, // S485
    {}, // S486
    {}, // S487
    {}, // S488
};

Token Lexer::get(){
    if(current == std::istream::traits_type::eof()){
        return Token(std::monostate(), pos);
    }
    while(true){
        if(states[state].contains(current)){
            state = states[state][current];
            current = fetch();
        }else if(states[state].contains('\0')){
            state = states[state]['\0'];
            current = fetch();
        }else{
            Position _pos = pos;
            pos = cur;
            std::string _text = text;
            if(current != std::istream::traits_type::eof()){
                _text.pop_back();
            }
            switch(state){
                // Action 0
                case 48:
                    stack.emplace_back(16, text);
                    state = 0;
                    text = current;
                break;
                // Action 1
                case 5:
                    stack.emplace_back(0, text);
                    state = 0;
                    text = current;
                break;
                // Action 2
                case 6:
                    state = stack.back().first;
                    text = current;
                    stack.pop_back();
                break;
                // Action 3
                case 3:
                    state = 0;
                    text = current;
                break;
                // Action 4
                case 4:
                    state = 0;
                    text = current;
                break;
                // Action 5
                case 2:
                    state = 0;
                    text = current;
                break;
                // Action 6
                case 1:
                    state = 0;
                    text = current;
                {
                    throw Exception::Parse("block comment not close", {_pos.line, _pos.column});
                }break;
                // Action 7
                case 55:
                    stack.emplace_back(16, text);
                    state = 7;
                    text = current;
                break;
                // Action 8
                case 8:
                case 10:
                    state = stack.back().first;
                    text = current;
                    stack.pop_back();
                break;
                // Action 9
                case 9:
                    state = 7;
                    text = current;
                break;
                // Action 10
                case 18:
                case 19:
                case 20:
                case 21:
                    state = 16;
                    text = current;
                break;
                // Action 11
                case 24:
                    state = 16;
                    text = current;
                {
                    return Token(ParenL(), _pos);
                }break;
                // Action 12
                case 25:
                    state = 16;
                    text = current;
                {
                    return Token(ParenR(), _pos);
                }break;
                // Action 13
                case 47:
                    state = 16;
                    text = current;
                {
                    return Token(Id(_text.substr(1)), _pos);
                }break;
                // Action 14
                case 22:
                    stack.emplace_back(16, text);
                    state = 11;
                    text = current;
                break;
                // Action 15
                case 14:
                    state = 11;
                    text = current;
                {
                    throw Exception::Parse("invalid character in string", {_pos.line, _pos.column});
                }break;
                // Action 16
                case 12:
                    state = 11;
                    text = current;
                {
                    throw Exception::Parse("string not close", {_pos.line, _pos.column});
                }break;
                // Action 17
                case 13:
                    state = 11;
                break;
                // Action 18
                case 15:
                    state = stack.back().first;
                    text = current;
                    stack.pop_back();
                {
                    return Token(String(_text.substr(0, _text.size() - 1)), _pos);
                }break;
                // Action 19
                case 27:
                case 28:
                case 52:
                    state = 16;
                    text = current;
                {
                    // Check underscore
                    if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                        throw Exception::Parse("integer can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
                    }
                    _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
                    return Token(Integer(_text), _pos);
                }break;
                // Action 20
                case 96:
                case 140:
                    state = 16;
                    text = current;
                {
                    // Check underscore
                    if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                        throw Exception::Parse("integer can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
                    }
                    _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
                    return Token(Integer(_text), _pos);
                }break;
                // Action 21
                case 116:
                case 123:
                case 351:
                case 395:
                    state = 16;
                    text = current;
                {
                    // Check underscore
                    if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                        throw Exception::Parse("floating number can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
                    }
                    _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
                    return Token(Float(_text), _pos);
                }break;
                // Action 22
                case 51:
                case 91:
                case 93:
                case 95:
                case 137:
                case 138:
                case 177:
                    state = 16;
                    text = current;
                {
                    // Check underscore
                    if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                        throw Exception::Parse("floating number can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
                    }
                    _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
                    return Token(Float(_text), _pos);
                }break;
                // Action 23
                case 139:
                case 178:
                case 180:
                case 182:
                case 238:
                case 239:
                case 301:
                    state = 16;
                    text = current;
                {
                    // Check underscore
                    if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                        throw Exception::Parse("floating number can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
                    }
                    _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
                    return Token(Float(_text), _pos);
                }break;
                // Action 24
                case 396:
                case 397:
                case 435:
                    state = 16;
                    text = current;
                {
                    // Check underscore
                    if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                        throw Exception::Parse("offset can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
                    }
                    _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
                    return Token(MemOffset(std::stoll(_text.substr(7))), _pos);
                }break;
                // Action 25
                case 462:
                case 482:
                    state = 16;
                    text = current;
                {
                    // Check underscore
                    if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                        throw Exception::Parse("offset can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
                    }
                    _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
                    return Token(MemOffset(std::stoll(_text.substr(7), nullptr, 16)), _pos);
                }break;
                // Action 26
                case 302:
                case 303:
                case 362:
                    state = 16;
                    text = current;
                {
                    // Check underscore
                    if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                        throw Exception::Parse("align can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
                    }
                    _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
                    return Token(MemAlign(std::stoll(_text.substr(6))), _pos);
                }break;
                // Action 27
                case 409:
                case 446:
                    state = 16;
                    text = current;
                {
                    // Check underscore
                    if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                        throw Exception::Parse("align can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
                    }
                    _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
                    return Token(MemAlign(std::stoll(_text.substr(6), nullptr, 16)), _pos);
                }break;
                // Action 28
                case 290:
                    state = 16;
                    text = current;
                {
                    return Token(Module(), _pos);
                }break;
                // Action 29
                case 175:
                    state = 16;
                    text = current;
                {
                    return Token(Type(), _pos);
                }break;
                // Action 30
                case 287:
                    state = 16;
                    text = current;
                {
                    return Token(Import(), _pos);
                }break;
                // Action 31
                case 246:
                    state = 16;
                    text = current;
                {
                    return Token(Export(), _pos);
                }break;
                // Action 32
                case 227:
                    state = 16;
                    text = current;
                {
                    return Token(Param(), _pos);
                }break;
                // Action 33
                case 296:
                    state = 16;
                    text = current;
                {
                    return Token(Result(), _pos);
                }break;
                // Action 34
                case 327:
                    state = 16;
                    text = current;
                {
                    return Token(Funcref(), _pos);
                }break;
                // Action 35
                case 247:
                    state = 16;
                    text = current;
                {
                    return Token(Extern(), _pos);
                }break;
                // Action 36
                case 413:
                    state = 16;
                    text = current;
                {
                    return Token(Externref(), _pos);
                }break;
                // Action 37
                case 109:
                case 110:
                case 113:
                case 114:
                    state = 16;
                    text = current;
                {
                    return Token(NumType(_text), _pos);
                }break;
                // Action 38
                case 155:
                    state = 16;
                    text = current;
                {
                    return Token(Func(), _pos);
                }break;
                // Action 39
                case 235:
                    state = 16;
                    text = current;
                {
                    return Token(Table(), _pos);
                }break;
                // Action 40
                case 289:
                    state = 16;
                    text = current;
                {
                    return Token(Memory(), _pos);
                }break;
                // Action 41
                case 266:
                    state = 16;
                    text = current;
                {
                    return Token(Global(), _pos);
                }break;
                // Action 42
                case 122:
                    state = 16;
                    text = current;
                {
                    return Token(Mut(), _pos);
                }break;
                // Action 43
                case 222:
                    state = 16;
                    text = current;
                {
                    return Token(Local(), _pos);
                }break;
                // Action 44
                case 150:
                    state = 16;
                    text = current;
                {
                    return Token(Elem(), _pos);
                }break;
                // Action 45
                case 160:
                    state = 16;
                    text = current;
                {
                    return Token(Item(), _pos);
                }break;
                // Action 46
                case 307:
                    state = 16;
                    text = current;
                {
                    return Token(Declare(), _pos);
                }break;
                // Action 47
                case 292:
                    state = 16;
                    text = current;
                {
                    return Token(Offset(), _pos);
                }break;
                // Action 48
                case 147:
                    state = 16;
                    text = current;
                {
                    return Token(Data(), _pos);
                }break;
                // Action 49
                case 234:
                    state = 16;
                    text = current;
                {
                    return Token(Start(), _pos);
                }break;
                // Action 50
                case 174:
                    state = 16;
                    text = current;
                {
                    return Token(Then(), _pos);
                }break;
                // Action 51
                case 124:
                case 297:
                case 484:
                    state = 16;
                    text = current;
                {
                    if(_text == "unreachable"){
                        return Token(ControlInstr(ControlInstr::Unreachable), _pos);
                    }else if(_text == "nop"){
                        return Token(ControlInstr(ControlInstr::Nop), _pos);
                    }else{
                        return Token(ControlInstr(ControlInstr::Return), _pos);
                    }
                }break;
                // Action 52
                case 184:
                    state = 16;
                    text = current;
                {
                    return Token(Block(), _pos);
                }break;
                // Action 53
                case 106:
                    state = 16;
                    text = current;
                {
                    return Token(End(), _pos);
                }break;
                // Action 54
                case 162:
                    state = 16;
                    text = current;
                {
                    return Token(Loop(), _pos);
                }break;
                // Action 55
                case 72:
                    state = 16;
                    text = current;
                {
                    return Token(If(), _pos);
                }break;
                // Action 56
                case 151:
                    state = 16;
                    text = current;
                {
                    return Token(Else(), _pos);
                }break;
                // Action 57
                case 58:
                    state = 16;
                    text = current;
                {
                    return Token(Br(), _pos);
                }break;
                // Action 58
                case 185:
                    state = 16;
                    text = current;
                {
                    return Token(Br_if(), _pos);
                }break;
                // Action 59
                case 364:
                    state = 16;
                    text = current;
                {
                    return Token(Br_table(), _pos);
                }break;
                // Action 60
                case 146:
                    state = 16;
                    text = current;
                {
                    return Token(Call(), _pos);
                }break;
                // Action 61
                case 488:
                    state = 16;
                    text = current;
                {
                    return Token(Call_indirect(), _pos);
                }break;
                // Action 62
                case 400:
                    state = 16;
                    text = current;
                {
                    return Token(Ref_null(), _pos);
                }break;
                // Action 63
                case 483:
                    state = 16;
                    text = current;
                {
                    return Token(Ref_is_null(), _pos);
                }break;
                // Action 64
                case 398:
                    state = 16;
                    text = current;
                {
                    return Token(Ref_func(), _pos);
                }break;
                // Action 65
                case 149:
                    state = 16;
                    text = current;
                {
                    return Token(Drop(), _pos);
                }break;
                // Action 66
                case 298:
                    state = 16;
                    text = current;
                {
                    return Token(Select(), _pos);
                }break;
                // Action 67
                case 427:
                case 428:
                case 429:
                    state = 16;
                    text = current;
                {
                    if(_text.starts_with("local")){
                        std::string op = _text.substr(6);
                        if(op == "get"){
                            return Token(VariableInstr(VariableInstr::LocalGet), _pos);
                        }else if(op == "set"){
                            return Token(VariableInstr(VariableInstr::LocalSet), _pos);
                        }else{
                            return Token(VariableInstr(VariableInstr::LocalTee), _pos);
                        }
                    }else{
                        std::string op = _text.substr(7);
                        if(op == "get"){
                            return Token(VariableInstr(VariableInstr::GlobalGet), _pos);
                        }else{
                            return Token(VariableInstr(VariableInstr::GlobalSet), _pos);
                        }
                    }
                }break;
                // Action 68
                case 440:
                case 443:
                case 465:
                case 466:
                case 468:
                    state = 16;
                    text = current;
                {
                    if(_text == "table.get"){
                        return Token(TableInstr(TableInstr::TableGet), _pos);
                    }else if(_text == "table.set"){
                        return Token(TableInstr(TableInstr::TableSet), _pos);
                    }else if(_text == "table.size"){
                        return Token(TableInstr(TableInstr::TableSize), _pos);
                    }else if(_text == "table.grow"){
                        return Token(TableInstr(TableInstr::TableGrow), _pos);
                    }else{
                        return Token(TableInstr(TableInstr::TableFill), _pos);
                    }
                }break;
                // Action 69
                case 464:
                    state = 16;
                    text = current;
                {
                    return Token(Table_copy(), _pos);
                }break;
                // Action 70
                case 467:
                    state = 16;
                    text = current;
                {
                    return Token(Table_init(), _pos);
                }break;
                // Action 71
                case 412:
                    state = 16;
                    text = current;
                {
                    return Token(Elem_drop(), _pos);
                }break;
                // Action 72
                case 481:
                    state = 16;
                    text = current;
                {
                    return Token(Memory_size(), _pos);
                }break;
                // Action 73
                case 479:
                    state = 16;
                    text = current;
                {
                    return Token(Memory_grow(), _pos);
                }break;
                // Action 74
                case 478:
                    state = 16;
                    text = current;
                {
                    return Token(Memory_fill(), _pos);
                }break;
                // Action 75
                case 480:
                    state = 16;
                    text = current;
                {
                    return Token(Memory_init(), _pos);
                }break;
                // Action 76
                case 477:
                    state = 16;
                    text = current;
                {
                    return Token(Memory_copy(), _pos);
                }break;
                // Action 77
                case 411:
                    state = 16;
                    text = current;
                {
                    return Token(Data_drop(), _pos);
                }break;
                // Action 78
                case 380:
                case 385:
                case 424:
                case 426:
                case 454:
                case 473:
                case 474:
                case 476:
                case 487:
                    state = 16;
                    text = current;
                {
                    if(_text.starts_with("i32")){
                        std::string op = _text.substr(4);
                        if(op.starts_with("load")){
                            op = op.substr(4);
                            if(op.starts_with("8")){
                                op = op.substr(2);
                                if(op == "s"){
                                    return Token(MemoryInstr(MemoryInstr::I32Load8_s), _pos);
                                }else{
                                    return Token(MemoryInstr(MemoryInstr::I32Load8_u), _pos);
                                }
                            }else if(op.starts_with("16")){
                                op = op.substr(3);
                                if(op == "s"){
                                    return Token(MemoryInstr(MemoryInstr::I32Load16_s), _pos);
                                }else{
                                    return Token(MemoryInstr(MemoryInstr::I32Load16_u), _pos);
                                }
                            }else{
                                return Token(MemoryInstr(MemoryInstr::I32Load), _pos);
                            }
                        }else{
                            op = op.substr(5);
                            if(op.starts_with("8")){
                                return Token(MemoryInstr(MemoryInstr::I32Store8), _pos);
                            }else if(op.starts_with("16")){
                                return Token(MemoryInstr(MemoryInstr::I32Store16), _pos);
                            }else{
                                return Token(MemoryInstr(MemoryInstr::I32Store), _pos);
                            }
                        }
                    }else{
                        std::string op = _text.substr(4);
                        if(op.starts_with("load")){
                            op = op.substr(4);
                            if(op.starts_with("8")){
                                op = op.substr(2);
                                if(op == "s"){
                                    return Token(MemoryInstr(MemoryInstr::I64Load8_s), _pos);
                                }else{
                                    return Token(MemoryInstr(MemoryInstr::I64Load8_u), _pos);
                                }
                            }else if(op.starts_with("16")){
                                op = op.substr(3);
                                if(op == "s"){
                                    return Token(MemoryInstr(MemoryInstr::I64Load16_s), _pos);
                                }else{
                                    return Token(MemoryInstr(MemoryInstr::I64Load16_u), _pos);
                                }
                            }else if(op.starts_with("32")){
                                op = op.substr(3);
                                if(op == "s"){
                                    return Token(MemoryInstr(MemoryInstr::I64Load32_s), _pos);
                                }else{
                                    return Token(MemoryInstr(MemoryInstr::I64Load32_u), _pos);
                                }
                            }else{
                                return Token(MemoryInstr(MemoryInstr::I64Load), _pos);
                            }
                        }else{
                            op = op.substr(5);
                            if(op.starts_with("8")){
                                return Token(MemoryInstr(MemoryInstr::I64Store8), _pos);
                            }else if(op.starts_with("16")){
                                return Token(MemoryInstr(MemoryInstr::I64Store16), _pos);
                            }else if(op.starts_with("32")){
                                return Token(MemoryInstr(MemoryInstr::I64Store32), _pos);
                            }else{
                                return Token(MemoryInstr(MemoryInstr::I64Store), _pos);
                            }
                        }
                    }
                }break;
                // Action 79
                case 373:
                case 418:
                    state = 16;
                    text = current;
                {
                    if(_text == "f32.load"){
                        return Token(MemoryInstr(MemoryInstr::F32Load), _pos);
                    }else if(_text == "f32.store"){
                        return Token(MemoryInstr(MemoryInstr::F32Store), _pos);
                    }else if(_text == "f64.load"){
                        return Token(MemoryInstr(MemoryInstr::F64Load), _pos);
                    }else{
                        return Token(MemoryInstr(MemoryInstr::F64Store), _pos);
                    }
                    return Token(I32_const(), _pos);
                }break;
                // Action 80
                case 414:
                    state = 16;
                    text = current;
                {
                    if(_text.starts_with("i32")){
                        return Token(I32_const(), _pos);
                    }else if(_text.starts_with("i64")){
                        return Token(I64_const(), _pos);
                    }else if(_text.starts_with("f32")){
                        return Token(F32_const(), _pos);
                    }else{
                        return Token(F64_const(), _pos);
                    }
                }break;
                // Action 81
                case 272:
                case 276:
                case 277:
                case 329:
                case 330:
                case 331:
                case 333:
                case 336:
                case 340:
                case 343:
                case 344:
                case 379:
                case 382:
                case 383:
                case 420:
                case 452:
                    state = 16;
                    text = current;
                {
                    if(_text.starts_with("i32")){
                        std::string op = _text.substr(4);
                        if(op == "eq"){
                            return Token(NumericInstr(NumericInstr::I32Eq), _pos);
                        }else if(op == "eqz"){
                            return Token(NumericInstr(NumericInstr::I32Eqz), _pos);
                        }else if(op == "ne"){
                            return Token(NumericInstr(NumericInstr::I32Ne), _pos);
                        }else if(op == "le_s"){
                            return Token(NumericInstr(NumericInstr::I32Le_s), _pos);
                        }else if(op == "lt_s"){
                            return Token(NumericInstr(NumericInstr::I32Lt_s), _pos);
                        }else if(op == "ge_s"){
                            return Token(NumericInstr(NumericInstr::I32Ge_s), _pos);
                        }else if(op == "gt_s"){
                            return Token(NumericInstr(NumericInstr::I32Gt_s), _pos);
                        }else if(op == "le_u"){
                            return Token(NumericInstr(NumericInstr::I32Le_u), _pos);
                        }else if(op == "lt_u"){
                            return Token(NumericInstr(NumericInstr::I32Lt_u), _pos);
                        }else if(op == "ge_u"){
                            return Token(NumericInstr(NumericInstr::I32Ge_u), _pos);
                        }else if(op == "gt_u"){
                            return Token(NumericInstr(NumericInstr::I32Gt_u), _pos);
                        }else if(op == "clz"){
                            return Token(NumericInstr(NumericInstr::I32Clz), _pos);
                        }else if(op == "ctz"){
                            return Token(NumericInstr(NumericInstr::I32Ctz), _pos);
                        }else if(op == "popcnt"){
                            return Token(NumericInstr(NumericInstr::I32Popcnt), _pos);
                        }else if(op == "add"){
                            return Token(NumericInstr(NumericInstr::I32Add), _pos);
                        }else if(op == "sub"){
                            return Token(NumericInstr(NumericInstr::I32Sub), _pos);
                        }else if(op == "mul"){
                            return Token(NumericInstr(NumericInstr::I32Mul), _pos);
                        }else if(op == "and"){
                            return Token(NumericInstr(NumericInstr::I32And), _pos);
                        }else if(op == "or"){
                            return Token(NumericInstr(NumericInstr::I32Or), _pos);
                        }else if(op == "xor"){
                            return Token(NumericInstr(NumericInstr::I32Xor), _pos);
                        }else if(op == "shl"){
                            return Token(NumericInstr(NumericInstr::I32Shl), _pos);
                        }else if(op == "rotl"){
                            return Token(NumericInstr(NumericInstr::I32Rotl), _pos);
                        }else if(op == "rotr"){
                            return Token(NumericInstr(NumericInstr::I32Rotr), _pos);
                        }else if(op == "div_s"){
                            return Token(NumericInstr(NumericInstr::I32Div_s), _pos);
                        }else if(op == "div_u"){
                            return Token(NumericInstr(NumericInstr::I32Div_u), _pos);
                        }else if(op == "rem_s"){
                            return Token(NumericInstr(NumericInstr::I32Rem_s), _pos);
                        }else if(op == "rem_u"){
                            return Token(NumericInstr(NumericInstr::I32Rem_u), _pos);
                        }else if(op == "shr_s"){
                            return Token(NumericInstr(NumericInstr::I32Shr_s), _pos);
                        }else{
                            return Token(NumericInstr(NumericInstr::I32Shr_u), _pos);
                        }
                    }else{
                        std::string op = _text.substr(4);
                        if(op == "eq"){
                            return Token(NumericInstr(NumericInstr::I64Eq), _pos);
                        }else if(op == "eqz"){
                            return Token(NumericInstr(NumericInstr::I64Eqz), _pos);
                        }else if(op == "ne"){
                            return Token(NumericInstr(NumericInstr::I64Ne), _pos);
                        }else if(op == "le_s"){
                            return Token(NumericInstr(NumericInstr::I64Le_s), _pos);
                        }else if(op == "lt_s"){
                            return Token(NumericInstr(NumericInstr::I64Lt_s), _pos);
                        }else if(op == "ge_s"){
                            return Token(NumericInstr(NumericInstr::I64Ge_s), _pos);
                        }else if(op == "gt_s"){
                            return Token(NumericInstr(NumericInstr::I64Gt_s), _pos);
                        }else if(op == "le_u"){
                            return Token(NumericInstr(NumericInstr::I64Le_u), _pos);
                        }else if(op == "lt_u"){
                            return Token(NumericInstr(NumericInstr::I64Lt_u), _pos);
                        }else if(op == "ge_u"){
                            return Token(NumericInstr(NumericInstr::I64Ge_u), _pos);
                        }else if(op == "gt_u"){
                            return Token(NumericInstr(NumericInstr::I64Gt_u), _pos);
                        }else if(op == "clz"){
                            return Token(NumericInstr(NumericInstr::I64Clz), _pos);
                        }else if(op == "ctz"){
                            return Token(NumericInstr(NumericInstr::I64Ctz), _pos);
                        }else if(op == "popcnt"){
                            return Token(NumericInstr(NumericInstr::I64Popcnt), _pos);
                        }else if(op == "add"){
                            return Token(NumericInstr(NumericInstr::I64Add), _pos);
                        }else if(op == "sub"){
                            return Token(NumericInstr(NumericInstr::I64Sub), _pos);
                        }else if(op == "mul"){
                            return Token(NumericInstr(NumericInstr::I64Mul), _pos);
                        }else if(op == "and"){
                            return Token(NumericInstr(NumericInstr::I64And), _pos);
                        }else if(op == "or"){
                            return Token(NumericInstr(NumericInstr::I64Or), _pos);
                        }else if(op == "xor"){
                            return Token(NumericInstr(NumericInstr::I64Xor), _pos);
                        }else if(op == "shl"){
                            return Token(NumericInstr(NumericInstr::I64Shl), _pos);
                        }else if(op == "rotl"){
                            return Token(NumericInstr(NumericInstr::I64Rotl), _pos);
                        }else if(op == "rotr"){
                            return Token(NumericInstr(NumericInstr::I64Rotr), _pos);
                        }else if(op == "div_s"){
                            return Token(NumericInstr(NumericInstr::I64Div_s), _pos);
                        }else if(op == "div_u"){
                            return Token(NumericInstr(NumericInstr::I64Div_u), _pos);
                        }else if(op == "rem_s"){
                            return Token(NumericInstr(NumericInstr::I64Rem_s), _pos);
                        }else if(op == "rem_u"){
                            return Token(NumericInstr(NumericInstr::I64Rem_u), _pos);
                        }else if(op == "shr_s"){
                            return Token(NumericInstr(NumericInstr::I64Shr_s), _pos);
                        }else{
                            return Token(NumericInstr(NumericInstr::I64Shr_u), _pos);
                        }
                    }
                }break;
                // Action 82
                case 253:
                case 255:
                case 260:
                case 310:
                case 311:
                case 315:
                case 318:
                case 319:
                case 320:
                case 322:
                case 325:
                case 369:
                case 375:
                case 416:
                case 419:
                case 472:
                case 486:
                    state = 16;
                    text = current;
                {
                    if(_text.starts_with("f32")){
                        std::string op = _text.substr(4);
                        if(op == "eq"){
                            return Token(NumericInstr(NumericInstr::F32Eq), _pos);
                        }else if(op == "ne"){
                            return Token(NumericInstr(NumericInstr::F32Ne), _pos);
                        }else if(op == "le"){
                            return Token(NumericInstr(NumericInstr::F32Le), _pos);
                        }else if(op == "lt"){
                            return Token(NumericInstr(NumericInstr::F32Lt), _pos);
                        }else if(op == "ge"){
                            return Token(NumericInstr(NumericInstr::F32Ge), _pos);
                        }else if(op == "gt"){
                            return Token(NumericInstr(NumericInstr::F32Gt), _pos);
                        }else if(op == "abs"){
                            return Token(NumericInstr(NumericInstr::F32Abs), _pos);
                        }else if(op == "neg"){
                            return Token(NumericInstr(NumericInstr::F32Neg), _pos);
                        }else if(op == "ceil"){
                            return Token(NumericInstr(NumericInstr::F32Ceil), _pos);
                        }else if(op == "floor"){
                            return Token(NumericInstr(NumericInstr::F32Floor), _pos);
                        }else if(op == "trunc"){
                            return Token(NumericInstr(NumericInstr::F32Trunc), _pos);
                        }else if(op == "nearest"){
                            return Token(NumericInstr(NumericInstr::F32Nearest), _pos);
                        }else if(op == "sqrt"){
                            return Token(NumericInstr(NumericInstr::F32Sqrt), _pos);
                        }else if(op == "add"){
                            return Token(NumericInstr(NumericInstr::F32Add), _pos);
                        }else if(op == "sub"){
                            return Token(NumericInstr(NumericInstr::F32Sub), _pos);
                        }else if(op == "mul"){
                            return Token(NumericInstr(NumericInstr::F32Mul), _pos);
                        }else if(op == "div"){
                            return Token(NumericInstr(NumericInstr::F32Div), _pos);
                        }else if(op == "min"){
                            return Token(NumericInstr(NumericInstr::F32Min), _pos);
                        }else if(op == "max"){
                            return Token(NumericInstr(NumericInstr::F32Max), _pos);
                        }else{
                            return Token(NumericInstr(NumericInstr::F32Copysign), _pos);
                        }
                    }else{
                        std::string op = _text.substr(4);
                        if(op == "eq"){
                            return Token(NumericInstr(NumericInstr::F64Eq), _pos);
                        }else if(op == "ne"){
                            return Token(NumericInstr(NumericInstr::F64Ne), _pos);
                        }else if(op == "le"){
                            return Token(NumericInstr(NumericInstr::F64Le), _pos);
                        }else if(op == "lt"){
                            return Token(NumericInstr(NumericInstr::F64Lt), _pos);
                        }else if(op == "ge"){
                            return Token(NumericInstr(NumericInstr::F64Ge), _pos);
                        }else if(op == "gt"){
                            return Token(NumericInstr(NumericInstr::F64Gt), _pos);
                        }else if(op == "abs"){
                            return Token(NumericInstr(NumericInstr::F64Abs), _pos);
                        }else if(op == "neg"){
                            return Token(NumericInstr(NumericInstr::F64Neg), _pos);
                        }else if(op == "ceil"){
                            return Token(NumericInstr(NumericInstr::F64Ceil), _pos);
                        }else if(op == "floor"){
                            return Token(NumericInstr(NumericInstr::F64Floor), _pos);
                        }else if(op == "trunc"){
                            return Token(NumericInstr(NumericInstr::F64Trunc), _pos);
                        }else if(op == "nearest"){
                            return Token(NumericInstr(NumericInstr::F64Nearest), _pos);
                        }else if(op == "sqrt"){
                            return Token(NumericInstr(NumericInstr::F64Sqrt), _pos);
                        }else if(op == "add"){
                            return Token(NumericInstr(NumericInstr::F64Add), _pos);
                        }else if(op == "sub"){
                            return Token(NumericInstr(NumericInstr::F64Sub), _pos);
                        }else if(op == "mul"){
                            return Token(NumericInstr(NumericInstr::F64Mul), _pos);
                        }else if(op == "div"){
                            return Token(NumericInstr(NumericInstr::F64Div), _pos);
                        }else if(op == "min"){
                            return Token(NumericInstr(NumericInstr::F64Min), _pos);
                        }else if(op == "max"){
                            return Token(NumericInstr(NumericInstr::F64Max), _pos);
                        }else{
                            return Token(NumericInstr(NumericInstr::F64Copysign), _pos);
                        }
                    }
                }break;
                // Action 83
                case 17:
                    state = 16;
                    text = current;
                {
                    return Token(std::monostate(), _pos);
                }break;
                default:
                    throw UnknownToken(_pos, text);
            }
        }
    }
}

const char* UnknownToken::what(){
    return msg.c_str();
}

} // namespace WasmVM


