/** generated by ParGen **/
#include "Lexer.hpp"


namespace WasmVM {

using namespace Tokens;

Lexer::Lexer(std::filesystem::path path, std::istream& stream) :
  stream(stream), state(16)
{
    current = fetch();
    pos.path = path;
}

Lexer::Chars::Chars(std::initializer_list<Chars::char_t> init) : min(init.begin()[0]){
    if(init.size() == 1){
        max = init.begin()[0];
    }else{
        max = init.begin()[1];
    }
}

bool Lexer::Chars::operator<(const Chars& rhs) const {
    return (min < rhs.min) && (max < rhs.min);
}

Lexer::Chars::char_t Lexer::fetch(){
    std::string line_end = "";
    Chars::char_t res = stream.get();
    if(res != std::istream::traits_type::eof()){
        line_end += res;
        text += res;
        if(line_end.size() > 2){
            line_end = line_end.substr(line_end.size() - 2);
        }
        if(text.ends_with("\n")){
            cur.line += 1;
            cur.column = 0;
        }else{
            cur.column += 1;
        }
    }
    return res;
}

std::vector<Lexer::State> Lexer::states = {
    {{{-1},1}, {{0},2}, {{40},3}, {{59},4}, }, // S0
    {}, // S1
    {}, // S2
    {{{59},5}, }, // S3
    {{{41},6}, }, // S4
    {}, // S5
    {}, // S6
    {{{-1},8}, {{0},9}, {{10},10}, }, // S7
    {}, // S8
    {}, // S9
    {}, // S10
    {{{-1},12}, {{0},13}, {{1,31},14}, {{34},15}, {{127},14}, }, // S11
    {}, // S12
    {}, // S13
    {}, // S14
    {}, // S15
    {{{-1},17}, {{9},18}, {{10},19}, {{13},20}, {{32},21}, {{34},22}, {{36},23}, {{40},24}, {{41},25}, {{43},26}, {{45},26}, {{48},27}, {{49,57},28}, {{59},29}, {{105},30}, {{109},31}, {{110},32}, }, // S16
    {}, // S17
    {}, // S18
    {}, // S19
    {}, // S20
    {}, // S21
    {}, // S22
    {{{33},33}, {{35,39},33}, {{42,43},33}, {{45,58},33}, {{60,90},33}, {{92},33}, {{94,122},33}, {{124},33}, {{126},33}, }, // S23
    {{{59},34}, }, // S24
    {}, // S25
    {{{48},27}, {{49,57},28}, {{105},30}, {{110},32}, }, // S26
    {{{46},35}, {{48,57},36}, {{69},37}, {{95},36}, {{101},37}, {{120},38}, }, // S27
    {{{46},35}, {{48,57},36}, {{69},37}, {{95},36}, {{101},37}, }, // S28
    {{{59},39}, }, // S29
    {{{110},40}, }, // S30
    {{{111},41}, }, // S31
    {{{97},42}, }, // S32
    {{{33},33}, {{35,39},33}, {{42,43},33}, {{45,58},33}, {{60,90},33}, {{92},33}, {{94,122},33}, {{124},33}, {{126},33}, }, // S33
    {}, // S34
    {{{48,57},43}, {{69},44}, {{95},45}, {{101},44}, }, // S35
    {{{46},35}, {{48,57},36}, {{69},37}, {{95},36}, {{101},37}, }, // S36
    {{{43},46}, {{45},46}, {{48,57},47}, }, // S37
    {{{48,57},48}, {{65,70},48}, {{97,102},48}, }, // S38
    {}, // S39
    {{{102},49}, }, // S40
    {{{100},50}, }, // S41
    {{{110},51}, }, // S42
    {{{48,57},45}, {{69},44}, {{95},45}, {{101},44}, }, // S43
    {{{43},52}, {{45},52}, {{48,57},53}, }, // S44
    {{{48,57},45}, {{69},44}, {{95},45}, {{101},44}, }, // S45
    {{{48,57},47}, }, // S46
    {{{48,57},54}, {{95},54}, }, // S47
    {{{46},55}, {{48,57},56}, {{65,70},56}, {{80},57}, {{95},56}, {{97,102},56}, {{112},57}, }, // S48
    {}, // S49
    {{{117},58}, }, // S50
    {{{58},59}, }, // S51
    {{{48,57},53}, }, // S52
    {{{48,57},60}, {{95},60}, }, // S53
    {{{48,57},54}, {{95},54}, }, // S54
    {{{48,57},61}, {{65,70},61}, {{80},62}, {{95},63}, {{97,102},61}, {{112},62}, }, // S55
    {{{46},55}, {{48,57},56}, {{65,70},56}, {{80},57}, {{95},56}, {{97,102},56}, {{112},57}, }, // S56
    {{{43},64}, {{45},64}, {{48,57},65}, }, // S57
    {{{108},66}, }, // S58
    {{{48},67}, }, // S59
    {{{48,57},60}, {{95},60}, }, // S60
    {{{48,57},63}, {{65,70},63}, {{80},62}, {{95},63}, {{97,102},63}, {{112},62}, }, // S61
    {{{43},68}, {{45},68}, {{48,57},69}, }, // S62
    {{{48,57},63}, {{65,70},63}, {{80},62}, {{95},63}, {{97,102},63}, {{112},62}, }, // S63
    {{{48,57},65}, }, // S64
    {{{48,57},70}, {{95},70}, }, // S65
    {{{101},71}, }, // S66
    {{{120},72}, }, // S67
    {{{48,57},69}, }, // S68
    {{{48,57},73}, {{95},73}, }, // S69
    {{{48,57},70}, {{95},70}, }, // S70
    {}, // S71
    {{{48,57},74}, {{65,70},74}, {{97,102},74}, }, // S72
    {{{48,57},73}, {{95},73}, }, // S73
    {{{48,57},75}, {{65,70},75}, {{95},75}, {{97,102},75}, }, // S74
    {{{48,57},75}, {{65,70},75}, {{95},75}, {{97,102},75}, }, // S75
};

Token Lexer::get(){
    if(current == std::istream::traits_type::eof()){
        return Token(std::monostate(), pos);
    }
    while(true){
        if(states[state].contains(current)){
            state = states[state][current];
            current = fetch();
        }else if(states[state].contains('\0')){
            state = states[state]['\0'];
            current = fetch();
        }else{
            Position _pos = pos;
            pos = cur;
            std::string _text = text;
            if(current != std::istream::traits_type::eof()){
                _text.pop_back();
            }
            switch(state){
                // Action 0
                case 34:
                    stack.emplace_back(16, text);
                    state = 0;
                    text = current;
                break;
                // Action 1
                case 5:
                    stack.emplace_back(0, text);
                    state = 0;
                    text = current;
                break;
                // Action 2
                case 6:
                    state = stack.back().first;
                    text = current;
                    stack.pop_back();
                break;
                // Action 3
                case 3:
                    state = 0;
                    text = current;
                break;
                // Action 4
                case 4:
                    state = 0;
                    text = current;
                break;
                // Action 5
                case 2:
                    state = 0;
                    text = current;
                break;
                // Action 6
                case 1:
                    state = 0;
                    text = current;
                {
                    throw Exception::Parse("block comment not close", {_pos.line, _pos.column});
                }break;
                // Action 7
                case 39:
                    stack.emplace_back(16, text);
                    state = 7;
                    text = current;
                break;
                // Action 8
                case 8:
                case 10:
                    state = stack.back().first;
                    text = current;
                    stack.pop_back();
                break;
                // Action 9
                case 9:
                    state = 7;
                    text = current;
                break;
                // Action 10
                case 18:
                case 19:
                case 20:
                case 21:
                    state = 16;
                    text = current;
                break;
                // Action 11
                case 24:
                    state = 16;
                    text = current;
                {
                    return Token(ParenL(), _pos);
                }break;
                // Action 12
                case 25:
                    state = 16;
                    text = current;
                {
                    return Token(ParenR(), _pos);
                }break;
                // Action 13
                case 33:
                    state = 16;
                    text = current;
                {
                    return Token(Module(), _pos);
                }break;
                // Action 14
                case 22:
                    stack.emplace_back(16, text);
                    state = 11;
                    text = current;
                break;
                // Action 15
                case 14:
                    state = 11;
                    text = current;
                {
                    throw Exception::Parse("invalid character in string", {_pos.line, _pos.column});
                }break;
                // Action 16
                case 12:
                    state = 11;
                    text = current;
                {
                    throw Exception::Parse("string not close", {_pos.line, _pos.column});
                }break;
                // Action 17
                case 13:
                    state = 11;
                break;
                // Action 18
                case 15:
                    state = stack.back().first;
                    text = current;
                    stack.pop_back();
                {
                    return Token(String(_text.substr(0, _text.size() - 1)), _pos);
                }break;
                // Action 19
                case 27:
                case 28:
                case 36:
                    state = 16;
                    text = current;
                {
                    // Check underscore
                    if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                        throw Exception::Parse("integer can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
                    }
                    _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
                    return Token(Integer(_text), _pos);
                }break;
                // Action 20
                case 48:
                case 56:
                    state = 16;
                    text = current;
                {
                    // Check underscore
                    if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                        throw Exception::Parse("integer can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
                    }
                    _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
                    return Token(Integer(_text), _pos);
                }break;
                // Action 21
                case 49:
                case 51:
                case 74:
                case 75:
                    state = 16;
                    text = current;
                {
                    // Check underscore
                    if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                        throw Exception::Parse("floating number can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
                    }
                    _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
                    return Token(Float(_text), _pos);
                }break;
                // Action 22
                case 35:
                case 43:
                case 45:
                case 47:
                case 53:
                case 54:
                case 60:
                    state = 16;
                    text = current;
                {
                    // Check underscore
                    if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                        throw Exception::Parse("floating number can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
                    }
                    _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
                    return Token(Float(_text), _pos);
                }break;
                // Action 23
                case 55:
                case 61:
                case 63:
                case 65:
                case 69:
                case 70:
                case 73:
                    state = 16;
                    text = current;
                {
                    // Check underscore
                    if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                        throw Exception::Parse("floating number can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
                    }
                    _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
                    return Token(Float(_text), _pos);
                }break;
                // Action 24
                case 71:
                    state = 16;
                    text = current;
                {
                    return Token(Module(), _pos);
                }break;
                // Action 25
                case 17:
                    state = 16;
                    text = current;
                {
                    return Token(std::monostate(), _pos);
                }break;
                default:
                    throw UnknownToken(_pos, text);
            }
        }
    }
}

const char* UnknownToken::what(){
    return msg.c_str();
}

} // namespace WasmVM


