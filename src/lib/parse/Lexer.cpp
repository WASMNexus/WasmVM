/** generated by ParGen **/
#include "Lexer.hpp"


namespace WasmVM {

using namespace Tokens;

Lexer::Lexer(std::filesystem::path path, std::istream& stream) :
  stream(stream), state(24)
{
    current = fetch();
    pos.path = path;
}

Lexer::Chars::Chars(std::initializer_list<Chars::char_t> init) : min(init.begin()[0]){
    if(init.size() == 1){
        max = init.begin()[0];
    }else{
        max = init.begin()[1];
    }
}

bool Lexer::Chars::operator<(const Chars& rhs) const {
    return (min < rhs.min) && (max < rhs.min);
}

Lexer::Chars::char_t Lexer::fetch(){
    std::string line_end = "";
    Chars::char_t res = stream.get();
    if(res != std::istream::traits_type::eof()){
        line_end += res;
        text += res;
        if(line_end.size() > 2){
            line_end = line_end.substr(line_end.size() - 2);
        }
        if(text.ends_with("\n")){
            cur.line += 1;
            cur.column = 0;
        }else{
            cur.column += 1;
        }
    }
    return res;
}

std::vector<Lexer::State> Lexer::states = {
    {{{-1},1}, {{0},2}, {{40},3}, {{59},4}, }, // S0
    {}, // S1
    {}, // S2
    {{{59},5}, }, // S3
    {{{41},6}, }, // S4
    {}, // S5
    {}, // S6
    {{{-1},8}, {{0},9}, {{10},10}, }, // S7
    {}, // S8
    {}, // S9
    {}, // S10
    {{{-1},12}, {{0},13}, {{1,31},14}, {{34},15}, {{92},16}, {{127},14}, }, // S11
    {}, // S12
    {}, // S13
    {}, // S14
    {}, // S15
    {{{34},17}, {{39},17}, {{48,57},18}, {{65,69},18}, {{92},17}, {{97,101},18}, {{110},17}, {{114},17}, {{116},17}, {{117},19}, }, // S16
    {}, // S17
    {{{48,57},20}, {{65,69},20}, {{97,101},20}, }, // S18
    {{{123},21}, }, // S19
    {}, // S20
    {{{48,57},22}, {{65,69},22}, {{95},22}, {{97,101},22}, }, // S21
    {{{48,57},22}, {{65,69},22}, {{95},22}, {{97,101},22}, {{125},23}, }, // S22
    {}, // S23
    {{{-1},25}, {{9},26}, {{10},27}, {{13},28}, {{32},29}, {{34},30}, {{36},31}, {{40},32}, {{41},33}, {{59},34}, {{109},35}, }, // S24
    {}, // S25
    {}, // S26
    {}, // S27
    {}, // S28
    {}, // S29
    {}, // S30
    {{{33},36}, {{35,39},36}, {{42,43},36}, {{45,58},36}, {{60,90},36}, {{92},36}, {{94,122},36}, {{124},36}, {{126},36}, }, // S31
    {{{59},37}, }, // S32
    {}, // S33
    {{{59},38}, }, // S34
    {{{111},39}, }, // S35
    {{{33},36}, {{35,39},36}, {{42,43},36}, {{45,58},36}, {{60,90},36}, {{92},36}, {{94,122},36}, {{124},36}, {{126},36}, }, // S36
    {}, // S37
    {}, // S38
    {{{100},40}, }, // S39
    {{{117},41}, }, // S40
    {{{108},42}, }, // S41
    {{{101},43}, }, // S42
    {}, // S43
};

Token Lexer::get(){
    if(current == std::istream::traits_type::eof()){
        return Token(std::monostate(), pos);
    }
    while(true){
        if(states[state].contains(current)){
            state = states[state][current];
            current = fetch();
        }else if(states[state].contains('\0')){
            state = states[state]['\0'];
            current = fetch();
        }else{
            Position _pos = pos;
            pos = cur;
            std::string _text = text;
            if(current != std::istream::traits_type::eof()){
                _text.pop_back();
            }
            switch(state){
                // Action 0
                case 37:
                    stack.emplace_back(24, text);
                    state = 0;
                    text = current;
                break;
                // Action 1
                case 5:
                    stack.emplace_back(0, text);
                    state = 0;
                    text = current;
                break;
                // Action 2
                case 6:
                    state = stack.back().first;
                    text = current;
                    stack.pop_back();
                break;
                // Action 3
                case 3:
                    state = 0;
                    text = current;
                break;
                // Action 4
                case 4:
                    state = 0;
                    text = current;
                break;
                // Action 5
                case 2:
                    state = 0;
                    text = current;
                break;
                // Action 6
                case 1:
                    state = 0;
                    text = current;
                {
                    throw Exception::Parse("block comment not close", {_pos.line, _pos.column});
                }break;
                // Action 7
                case 38:
                    stack.emplace_back(24, text);
                    state = 7;
                    text = current;
                break;
                // Action 8
                case 8:
                case 10:
                    state = stack.back().first;
                    text = current;
                    stack.pop_back();
                break;
                // Action 9
                case 9:
                    state = 7;
                    text = current;
                break;
                // Action 10
                case 26:
                case 27:
                case 28:
                case 29:
                    state = 24;
                    text = current;
                break;
                // Action 11
                case 32:
                    state = 24;
                    text = current;
                {
                    return Token(ParenL(), _pos);
                }break;
                // Action 12
                case 33:
                    state = 24;
                    text = current;
                {
                    return Token(ParenR(), _pos);
                }break;
                // Action 13
                case 36:
                    state = 24;
                    text = current;
                {
                    return Token(Module(), _pos);
                }break;
                // Action 14
                case 30:
                    stack.emplace_back(24, text);
                    state = 11;
                    text = current;
                break;
                // Action 15
                case 14:
                    state = 11;
                    text = current;
                {
                    throw Exception::Parse("invalid character in string", {_pos.line, _pos.column});
                }break;
                // Action 16
                case 12:
                    state = 11;
                    text = current;
                {
                    throw Exception::Parse("string not close", {_pos.line, _pos.column});
                }break;
                // Action 17
                case 13:
                case 17:
                case 20:
                case 23:
                    state = 11;
                break;
                // Action 18
                case 15:
                    state = stack.back().first;
                    text = current;
                    stack.pop_back();
                {
                    return Token(String(_text.substr(0, _text.size() - 1)), _pos);
                }break;
                // Action 19
                case 43:
                    state = 24;
                    text = current;
                {
                    return Token(Module(), _pos);
                }break;
                // Action 20
                case 25:
                    state = 24;
                    text = current;
                {
                    return Token(std::monostate(), _pos);
                }break;
                default:
                    throw UnknownToken(_pos, text);
            }
        }
    }
}

const char* UnknownToken::what(){
    return msg.c_str();
}

} // namespace WasmVM


