/** generated by ParGen **/
#include "Lexer.hpp"


namespace WasmVM {

using namespace Tokens;

Lexer::Lexer(std::filesystem::path path, std::istream& stream) :
  stream(stream), state(11)
{
    current = fetch();
    pos.path = path;
}

Lexer::Chars::Chars(std::initializer_list<Chars::char_t> init) : min(init.begin()[0]){
    if(init.size() == 1){
        max = init.begin()[0];
    }else{
        max = init.begin()[1];
    }
}

bool Lexer::Chars::operator<(const Chars& rhs) const {
    return (min < rhs.min) && (max < rhs.min);
}

Lexer::Chars::char_t Lexer::fetch(){
    std::string line_end = "";
    Chars::char_t res = stream.get();
    if(res != std::istream::traits_type::eof()){
        line_end += res;
        text += res;
        if(line_end.size() > 2){
            line_end = line_end.substr(line_end.size() - 2);
        }
        if(text.ends_with("\n")){
            cur.line += 1;
            cur.column = 0;
        }else{
            cur.column += 1;
        }
    }
    return res;
}

std::vector<Lexer::State> Lexer::states = {
    {{{-1},1}, {{0},2}, {{40},3}, {{59},4}, }, // S0
    {}, // S1
    {}, // S2
    {{{59},5}, }, // S3
    {{{41},6}, }, // S4
    {}, // S5
    {}, // S6
    {{{-1},8}, {{0},9}, {{10},10}, }, // S7
    {}, // S8
    {}, // S9
    {}, // S10
    {{{-1},12}, {{9},13}, {{10},14}, {{13},15}, {{32},16}, {{40},17}, {{41},18}, {{59},19}, {{109},20}, }, // S11
    {}, // S12
    {}, // S13
    {}, // S14
    {}, // S15
    {}, // S16
    {{{59},21}, }, // S17
    {}, // S18
    {{{59},22}, }, // S19
    {{{111},23}, }, // S20
    {}, // S21
    {}, // S22
    {{{100},24}, }, // S23
    {{{117},25}, }, // S24
    {{{108},26}, }, // S25
    {{{101},27}, }, // S26
    {}, // S27
};

Token Lexer::get(){
    if(current == std::istream::traits_type::eof()){
        return Token(std::monostate(), pos);
    }
    while(true){
        if(states[state].contains(current)){
            state = states[state][current];
            current = fetch();
        }else if(states[state].contains('\0')){
            state = states[state]['\0'];
            current = fetch();
        }else{
            Position _pos = pos;
            pos = cur;
            std::string _text = text;
            if(current != std::istream::traits_type::eof()){
                _text.pop_back();
            }
            switch(state){
                // Action 0
                case 21:
                    stack.emplace_back(11, text);
                    state = 0;
                    text = current;
                break;
                // Action 1
                case 5:
                    stack.emplace_back(0, text);
                    state = 0;
                    text = current;
                break;
                // Action 2
                case 6:
                    state = stack.back().first;
                    text = current;
                    stack.pop_back();
                break;
                // Action 3
                case 3:
                    state = 0;
                    text = current;
                break;
                // Action 4
                case 4:
                    state = 0;
                    text = current;
                break;
                // Action 5
                case 2:
                    state = 0;
                    text = current;
                break;
                // Action 6
                case 1:
                    state = 0;
                    text = current;
                {
                    throw Exception::Parse("block comment not close", {_pos.line, _pos.column});
                }break;
                // Action 7
                case 22:
                    stack.emplace_back(11, text);
                    state = 7;
                    text = current;
                break;
                // Action 8
                case 8:
                case 10:
                    state = stack.back().first;
                    text = current;
                    stack.pop_back();
                break;
                // Action 9
                case 9:
                    state = 7;
                    text = current;
                break;
                // Action 10
                case 13:
                case 14:
                case 15:
                case 16:
                    state = 11;
                    text = current;
                break;
                // Action 11
                case 17:
                    state = 11;
                    text = current;
                {
                    return Token(ParenL(), _pos);
                }break;
                // Action 12
                case 18:
                    state = 11;
                    text = current;
                {
                    return Token(ParenR(), _pos);
                }break;
                // Action 13
                case 27:
                    state = 11;
                    text = current;
                {
                    return Token(Module(), _pos);
                }break;
                // Action 14
                case 12:
                    state = 11;
                    text = current;
                {
                    return Token(std::monostate(), _pos);
                }break;
                default:
                    throw UnknownToken(_pos, text);
            }
        }
    }
}

const char* UnknownToken::what(){
    return msg.c_str();
}

} // namespace WasmVM


