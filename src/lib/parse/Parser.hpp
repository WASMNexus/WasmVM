/** generated by ParGen **/
#ifndef ParGen_Parser_guard
#define ParGen_Parser_guard

#include <structures/WasmModule.hpp>
#include <exception.hpp>
        
#include <map>
#include <set>
#include <list>
#include <string>
#include <utility>
#include <vector>
#include <optional>
#include <initializer_list>
#include "Token.hpp"
#include "Lexer.hpp"

namespace WasmVM {

struct Parser {
    Parser(Lexer& lexer);
    WasmModule parse();
    constexpr static size_t End = (size_t)-1;
    using term_t = uint8_t;
    using token_t = Token;
protected:
    Lexer& lexer;
    using Act = std::pair<size_t, std::vector<bool>>;
    using State = std::map<term_t, std::vector<Act>>;
    struct Entry;
    struct Node {
        size_t action;
        std::vector<bool> param_toggle;
        std::list<Entry> children;
        std::list<std::pair<term_t,token_t>> flatten();
    };
    struct Entry {
        term_t term;
        size_t state;
        size_t branch = 0;
        std::variant<std::monostate, Node, token_t> elem;
    };
    struct Stack : public std::list<Entry>{
        void push(std::pair<term_t,token_t> token, size_t state){
            emplace_front(Entry {.term = token.first, .state = state, .elem = token.second});
        }
        void reduce(size_t action, std::vector<bool> param_toggle);
    };

    std::list<std::pair<term_t,token_t>> buffer;
    static std::vector<State> table;
    std::pair<term_t,token_t> fetch();
    WasmModule expand_tree(Entry&);
};

struct ParseError : public std::exception {
    ParseError(Parser::term_t term);
    std::string msg;
    const char* what(){
        return msg.c_str();
    }
};

} // namespace WasmVM

#endif 
