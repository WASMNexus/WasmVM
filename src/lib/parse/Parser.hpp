/** generated by ParGen **/
#ifndef ParGen_Parser_guard
#define ParGen_Parser_guard

#include <structures/WasmModule.hpp>
#include <exception.hpp>
#include <map>
#include <set>
#include <vector>
#include <utility>
#include <algorithm>
        
#include <map>
#include <set>
#include <list>
#include <string>
#include <utility>
#include <vector>
#include <optional>
#include <initializer_list>
#include "Token.hpp"
#include "Lexer.hpp"

namespace WasmVM {

struct Parser {
    Parser(Lexer& lexer);
    WasmModule parse();

    struct IndexMap {
        enum IndexType {Import, Normal};
        using Index = std::pair<IndexType, index_t>;
        struct Compare {
            bool operator()(const Index& lhs, const Index& rhs) const {
                if(lhs.first != rhs.first){
                    return lhs.first == IndexType::Import;
                }
                return lhs.second < rhs.second;
            }
        };
        index_t insert(IndexType type);
        index_t insert(std::string id, IndexType type);
        index_t get(std::string id);
        bool contains(std::string id);
        std::optional<Index> operator[](index_t index);
        private:
        index_t serial = 0;
        std::set<Index, Compare> indices;
        std::vector<std::set<Index, Compare>::iterator> handlers;
        std::map<std::string, index_t> id_map;
    };
    std::vector<std::pair<FuncType, std::map<std::string, index_t>>> types;
    std::map<std::string, index_t> type_indices;
    IndexMap func_indices;
    IndexMap table_indices;
    IndexMap mem_indices;
    IndexMap global_indices;
    void reset();
    constexpr static size_t End = (size_t)-1;
    using term_t = uint8_t;
    using token_t = Token;
protected:
    Lexer& lexer;
    using Act = std::pair<size_t, std::vector<bool>>;
    using State = std::map<term_t, std::vector<Act>>;
    struct Entry;
    struct Node {
        size_t action;
        std::vector<bool> param_toggle;
        std::list<Entry> children;
        std::list<std::pair<term_t,token_t>> flatten();
    };
    struct Entry {
        term_t term;
        size_t state;
        size_t branch = 0;
        std::variant<std::monostate, Node, token_t> elem;
    };
    struct Stack : public std::list<Entry>{
        void push(std::pair<term_t,token_t> token, size_t state){
            emplace_front(Entry {.term = token.first, .state = state, .elem = token.second});
        }
        void reduce(size_t action, std::vector<bool> param_toggle);
    };

    std::list<std::pair<term_t,token_t>> buffer;
    static std::vector<State> table;
    std::pair<term_t,token_t> fetch();
    WasmModule expand_tree(Entry&);
};

struct ParseError : public std::exception {
    ParseError(Position pos, Parser::term_t term);
    Position pos;
    std::string msg;
    const char* what(){
        return msg.c_str();
    }
};

} // namespace WasmVM

#endif 
