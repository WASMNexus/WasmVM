<!DOCTYPE pxml>
<pxml>
    <parser class="Parser" headerFile="Parser.hpp" sourceFile="Parser.cpp" start="module" return="WasmModule">
        {% header file %}
        <header indent=0 position="top">
            #include \<structures/WasmModule.hpp>
            #include \<exception.hpp>
            #include \<map>
            #include \<set>
            #include \<vector>
            #include \<utility>
            #include \<algorithm>
        </header>
        {% members %}
        <member>
            struct IndexMap {
                enum IndexType {Import, Normal};
                using Index = std::pair\<IndexType, index_t>;
                struct Compare {
                    bool operator()(const Index& lhs, const Index& rhs) const {
                        if(lhs.first != rhs.first){
                            return lhs.first == IndexType::Import;
                        }
                        return lhs.second \< rhs.second;
                    }
                };
                index_t insert(IndexType type);
                index_t insert(std::string id, IndexType type);
                index_t get(std::string id);
                bool contains(std::string id);
                std::optional\<Index> operator[](index_t index);
                private:
                index_t serial = 0;
                std::set\<Index, Compare> indices;
                std::vector\<std::set\<Index, Compare>::iterator> handlers;
                std::map\<std::string, index_t> id_map;
            };
            index_t local_count = 0;
            std::vector\<std::pair\<FuncType, std::map\<std::string, index_t>>> types;
            std::map\<std::string, index_t> type_indices;
            std::map\<std::string, index_t> local_indices;
            std::map\<std::string, WasmExport> exports;
            IndexMap func_indices;
            IndexMap table_indices;
            IndexMap mem_indices;
            IndexMap global_indices;
            void reset();
            void clear_locals() {
                local_indices.clear();
                local_count = 0;
            }
        </member>
        <source indent=0 position="bottom">
            namespace WasmVM {
            index_t Parser::IndexMap::insert(IndexType type){
                index_t index = handlers.size();
                handlers.emplace_back(indices.emplace(type, serial++).first);
                return index;
            }
            index_t Parser::IndexMap::insert(std::string id, IndexType type){
                if(!id_map.contains(id)){
                    id_map[id] = insert(type);
                }
                return id_map[id];
            }
            index_t Parser::IndexMap::get(std::string id){
                return id_map.contains(id) ? id_map[id] : -1;
            }
            bool Parser::IndexMap::contains(std::string id){
                return id_map.contains(id);
            }
            std::optional\<Parser::IndexMap::Index> Parser::IndexMap::operator[](index_t index){
                if(index \< handlers.size()){
                    return *handlers[index];
                }
                return std::nullopt;
            }
            void Parser::reset(){
                types.clear();
                exports.clear();
                type_indices.clear();
                func_indices = IndexMap();
                table_indices = IndexMap();
                mem_indices = IndexMap();
                global_indices = IndexMap();
            }
            } // namespace WasmVM
        </source>
        {% targets %}
        <target name="modulefield" type="WasmModule">
            <grammar pattern="modulefield type">
                _this.clear_locals();
                return _op0;
            </grammar>
            <grammar pattern="modulefield import">
                _op0.imports.emplace_back(_op1);
                _this.clear_locals();
                return _op0;
            </grammar>
            <grammar pattern="modulefield table">
                if(std::holds_alternative\<WasmImport>(_op1)){
                    _op0.imports.emplace_back(std::get\<WasmImport>(_op1));
                }else{
                    _op0.tables.emplace_back(std::get\<TableType>(_op1));
                }
                return _op0;
            </grammar>
            <grammar pattern="modulefield memory">
                if(std::holds_alternative\<WasmImport>(_op1)){
                    _op0.imports.emplace_back(std::get\<WasmImport>(_op1));
                }else{
                    _op0.mems.emplace_back(std::get\<Limits>(_op1));
                }
                return _op0;
            </grammar>
            <grammar pattern="modulefield global">
                if(std::holds_alternative\<WasmImport>(_op1)){
                    _op0.imports.emplace_back(std::get\<WasmImport>(_op1));
                }else{
                    _op0.globals.emplace_back(std::get\<WasmGlobal>(_op1));
                }
                return _op0;
            </grammar>
            <grammar pattern="modulefield export">
                _this.exports[_op1.name] = _op1;
                return _op0;
            </grammar>
            <grammar pattern="modulefield func">
                if(std::holds_alternative\<WasmImport>(_op1)){
                    _op0.imports.emplace_back(std::get\<WasmImport>(_op1));
                }else{
                    _op0.funcs.emplace_back(std::get\<WasmFunc>(_op1));
                }
                _this.clear_locals();
                return _op0;
            </grammar>
            <grammar pattern="modulefield ParenL Start funcidx ParenR">
                if(_op0.start.has_value()){
                    throw Exception::Parse("multiple start functions", {_pos[1].line, _pos[1].column});
                }
                _op0.start = _op3;
                return _op0;
            </grammar>
            <grammar>
                return WasmModule();
            </grammar>
        </target>
        <target name="module" type="WasmModule">
            <grammar pattern="ParenL Module Id modulefield ParenR">
                for(auto& functype : _this.types){
                    _op3.types.emplace_back(functype.first);
                }
                for(auto& exports : _this.exports){
                    _op3.exports.emplace_back(exports.second);
                }
                _this.reset();
                return _op3;
            </grammar>
            <grammar pattern="ParenL Module modulefield ParenR">
                for(auto& functype : _this.types){
                    _op2.types.emplace_back(functype.first);
                }
                for(auto& exports : _this.exports){
                    _op2.exports.emplace_back(exports.second);
                }
                _this.reset();
                return _op2;
            </grammar>
            <grammar pattern="modulefield">
                for(auto& functype : _this.types){
                    _op0.types.emplace_back(functype.first);
                }
                for(auto& exports : _this.exports){
                    _op0.exports.emplace_back(exports.second);
                }
                _this.reset();
                return _op0;
            </grammar>
            <grammar pattern="ParenL ParenR">
                _this.reset();
                return WasmModule();
            </grammar>
            <grammar pattern="EOF">
                _this.reset();
                return WasmModule();
            </grammar>
        </target>
        <target name="valtype" type="ValueType">
            <grammar pattern="NumType">
                if(_op0.value == "i32"){
                    return ValueType::i32;
                }else if(_op0.value == "i64"){
                    return ValueType::i64;
                }else if(_op0.value == "f32"){
                    return ValueType::f32;
                }else{
                    return ValueType::f64;
                }
            </grammar>
            <grammar pattern="Funcref">
                return ValueType::funcref;
            </grammar>
            <grammar pattern="Externref">
                return ValueType::externref;
            </grammar>
        </target>
        <target name="reftype" type="RefType">
            <grammar pattern="Funcref">
                return RefType::funcref;
            </grammar>
            <grammar pattern="Externref">
                return RefType::externref;
            </grammar>
        </target>
        <target name="valtypes" type="std::vector<ValueType>">
            <grammar pattern="valtypes valtype">
                _op0.emplace_back(_op1);
                return _op0;
            </grammar>
            <grammar>
                return std::vector\<ValueType>();
            </grammar>
        </target>
        <target name="params" type="std::vector<ValueType>">
            <grammar pattern="params ParenL Param Id valtype ParenR">
                if(_this.local_indices.contains(_op3.value)){
                    throw Exception::Parse("parameter ID '" + _op3.value + "' is duplicated", {_pos[3].line, _pos[3].column});
                }
                _this.local_indices[_op3.value] = _this.local_count;
                _this.local_count += 1;
                _op0.emplace_back(_op4);
                return _op0;
            </grammar>
            <grammar pattern="params ParenL Param valtypes ParenR">
                _op0.insert(_op0.end(), _op3.begin(), _op3.end());
                _this.local_count += _op3.size();
                return _op0;
            </grammar>
            <grammar>
                return std::vector\<ValueType>();
            </grammar>
        </target>
        <target name="results" type="std::vector<ValueType>">
            <grammar pattern="results ParenL Result valtypes ParenR">
                _op0.insert(_op0.end(), _op3.begin(), _op3.end());
                return _op0;
            </grammar>
            <grammar>
                return std::vector\<ValueType>();
            </grammar>
        </target>
        <target name="functype" type="FuncType">
            <grammar pattern="ParenL Func params results ParenR">
                return FuncType {.params = _op2, .results = _op3};
            </grammar>
        </target>
        <target name="heaptype" type="RefType">
            <grammar pattern="Func">
                return RefType::funcref;
            </grammar>
            <grammar pattern="Extern">
                return RefType::externref;
            </grammar>
        </target>
        <target name="id" type="std::string">
            <grammar pattern="Id">
                return _op0.value;
            </grammar>
            <grammar>
                return "";
            </grammar>
        </target>
        <target name="type">
            <grammar pattern="ParenL Type id functype ParenR">
                if(!_op2.empty()){
                    if(_this.type_indices.contains(_op2)){
                        throw Exception::Parse("type ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
                    }
                    _this.type_indices[_op2] = _this.types.size();
                }
                _this.types.emplace_back(_op3, _this.local_indices);
            </grammar>
        </target>
        <target name="u32" type="u32_t">
            <grammar pattern="Integer">
                try{
                    return std::stoul(_op0.value, 0);
                }catch(std::invalid_argument){
                    throw Exception::Parse("invalid u32 integer '" + _op0.value + "'", {_pos[0].line, _pos[0].column});
                }
            </grammar>
        </target>
        <target name="u64" type="u64_t">
            <grammar pattern="Integer">
                try{
                    return std::stoull(_op0.value, 0);
                }catch(std::invalid_argument){
                    throw Exception::Parse("invalid u64 integer '" + _op0.value + "'", {_pos[0].line, _pos[0].column});
                }
            </grammar>
        </target>
        <target name="i32" type="i32_t">
            <grammar pattern="Integer">
                try{
                    return std::stol(_op0.value, 0);
                }catch(std::invalid_argument){
                    throw Exception::Parse("invalid i32 integer '" + _op0.value + "'", {_pos[0].line, _pos[0].column});
                }
            </grammar>
        </target>
        <target name="i64" type="i64_t">
            <grammar pattern="Integer">
                try{
                    return std::stoll(_op0.value, 0);
                }catch(std::invalid_argument){
                    throw Exception::Parse("invalid i64 integer '" + _op0.value + "'", {_pos[0].line, _pos[0].column});
                }
            </grammar>
        </target>
        <target name="f32" type="f32_t">
            <grammar pattern="Float">
                try{
                    auto nanpos = _op0.value.find("nan:0x");
                    if(nanpos != std::string::npos){
                        u32_t nan_imm = 0x7f800000UL + std::stoul(_op0.value.substr(nanpos + 4), nullptr, 16);
                        if(_op0.value.starts_with("-")){
                            nan_imm += 0x80000000UL;
                        }
                        return *reinterpret_cast\<f32_t*>(&nan_imm);
                    }else{
                        return std::stof(_op0.value);
                    }
                }catch(std::invalid_argument){
                    throw Exception::Parse("invalid f32 number '" + _op0.value + "'", {_pos[0].line, _pos[0].column});
                }
            </grammar>
        </target>
        <target name="f64" type="f64_t">
            <grammar pattern="Float">
                try{
                    auto nanpos = _op0.value.find("nan:0x");
                    if(nanpos != std::string::npos){
                        u64_t nan_imm = 0x7ff0000000000000ULL + std::stoull(_op0.value.substr(nanpos + 4), nullptr, 16);
                        if(_op0.value.starts_with("-")){
                            nan_imm += 0x8000000000000000ULL;
                        }
                        return *reinterpret_cast\<f64_t*>(&nan_imm);
                    }else{
                        return std::stod(_op0.value);
                    }
                }catch(std::invalid_argument){
                    throw Exception::Parse("invalid f64 number '" + _op0.value + "'", {_pos[0].line, _pos[0].column});
                }
            </grammar>
        </target>
        <target name="typeidx" type="u32_t">
            <grammar pattern="u32">
                return _op0;
            </grammar>
            <grammar pattern="Id">
                if(!_this.type_indices.contains(_op0.value)){
                    throw Exception::Parse("type ID '" + _op0.value + "' not found", {_pos[0].line, _pos[0].column});
                }
                return _this.type_indices[_op0.value];
            </grammar>
        </target>
        <target name="funcidx" type="u32_t">
            <grammar pattern="u32">
                return _op0;
            </grammar>
            <grammar pattern="Id">
                index_t index = _this.func_indices.get(_op0.value);
                if(index == -1){
                    throw Exception::Parse("function ID '" + _op0.value + "' not found", {_pos[0].line, _pos[0].column});
                }
                return index;
            </grammar>
        </target>
        <target name="tableidx" type="u32_t">
            <grammar pattern="u32">
                return _op0;
            </grammar>
            <grammar pattern="Id">
                index_t index = _this.table_indices.get(_op0.value);
                if(index == -1){
                    throw Exception::Parse("table ID '" + _op0.value + "' not found", {_pos[0].line, _pos[0].column});
                }
                return index;
            </grammar>
        </target>
        <target name="memidx" type="u32_t">
            <grammar pattern="u32">
                return _op0;
            </grammar>
            <grammar pattern="Id">
                index_t index = _this.mem_indices.get(_op0.value);
                if(index == -1){
                    throw Exception::Parse("memory ID '" + _op0.value + "' not found", {_pos[0].line, _pos[0].column});
                }
                return index;
            </grammar>
        </target>
        <target name="globalidx" type="u32_t">
            <grammar pattern="u32">
                return _op0;
            </grammar>
            <grammar pattern="Id">
                index_t index = _this.global_indices.get(_op0.value);
                if(index == -1){
                    throw Exception::Parse("global ID '" + _op0.value + "' not found", {_pos[0].line, _pos[0].column});
                }
                return index;
            </grammar>
        </target>
        <target name="typeuse" type="u32_t">
            <grammar pattern="ParenL Type typeidx ParenR params results">
                if(_op4.empty() && _op5.empty()){
                    return _op2;
                }
                std::pair\<FuncType, std::map\<std::string, index_t>> derived = _this.types[_op2];
                for(auto& id_pair : _this.local_indices){
                    if(derived.second.contains(id_pair.first)){
                        throw Exception::Parse("parameter ID '" + id_pair.first + "' is duplicated", {_pos[4].line, _pos[4].column});
                    }
                    derived.second[id_pair.first] = id_pair.second + derived.first.params.size();
                }
                derived.first.params.insert(derived.first.params.end(), _op4.begin(), _op4.end());
                derived.first.results.insert(derived.first.results.end(), _op5.begin(), _op5.end());
                index_t index = _this.types.size();
                _this.types.emplace_back(derived);
                return index;
            </grammar>
            <grammar pattern="params results">
                index_t index = _this.types.size();
                _this.types.emplace_back(FuncType {.params = _op0, .results = _op1}, _this.local_indices);
                return index;
            </grammar>
            <grammar>
                index_t index = _this.types.size();
                _this.types.emplace_back(FuncType(), std::map\<std::string, index_t>());
                return index;
            </grammar>
        </target>
        <target name="limits" type="Limits">
            <grammar pattern="u64">
                return Limits {.min = _op0};
            </grammar>
            <grammar pattern="u64 u64">
                return Limits {.min = _op0, .max = _op1};
            </grammar>
        </target>
        <target name="tabletype" type="TableType">
            <grammar pattern="limits reftype">
                return TableType {.limits = _op0, .reftype = _op1};
            </grammar>
        </target>
        <target name="globaltype" type="GlobalType">
            <grammar pattern="valtype">
                return GlobalType {.mut = GlobalType::constant, .type = _op0};
            </grammar>
            <grammar pattern="ParenL Mut valtype ParenR">
                return GlobalType {.mut = GlobalType::variable, .type = _op2};
            </grammar>
        </target>
        <target name="constexpr" type="ConstInstr">
            <grammar pattern="Ref_null heaptype">
                return Instr::Ref_null(_op1);
            </grammar>
            <grammar pattern="Ref_func funcidx">
                return Instr::Ref_func(_op1);
            </grammar>
            <grammar pattern="I32_const i32">
                return Instr::I32_const(_op1);
            </grammar>
            <grammar pattern="I64_const i64">
                return Instr::I64_const(_op1);
            </grammar>
            <grammar pattern="F32_const f32">
                return Instr::F32_const(_op1);
            </grammar>
            <grammar pattern="F64_const f64">
                return Instr::F64_const(_op1);
            </grammar>
            <grammar pattern="VariableInstr globalidx">
                if(_op0.value != VariableInstr::GlobalGet){
                    throw Exception::Parse("invalid expr in global init ", {_pos[0].line, _pos[0].column});
                }
                return Instr::Global_get(_op1);
            </grammar>
        </target>
        <target name="import" type="WasmImport">
            <grammar pattern="ParenL Import String String importdesc ParenR">
                return WasmImport {.module = _op2.value, .name = _op3.value, .desc = _op4};
            </grammar>
        </target>
        <target name="importdesc" type="std::variant<index_t, TableType, MemType, GlobalType>">
            <grammar pattern="ParenL Func id typeuse ParenR">
                if(!_op2.empty()){
                    if(_this.func_indices.contains(_op2)){
                        throw Exception::Parse("function ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
                    }
                    _this.func_indices.insert(_op2, Parser::IndexMap::Import);
                }else{
                    _this.func_indices.insert(Parser::IndexMap::Import);
                }
                return _op3;
            </grammar>
            <grammar pattern="ParenL Table id tabletype ParenR">
                if(!_op2.empty()){
                    if(_this.table_indices.contains(_op2)){
                        throw Exception::Parse("table ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
                    }
                    _this.table_indices.insert(_op2, Parser::IndexMap::Import);
                }else{
                    _this.table_indices.insert(Parser::IndexMap::Import);
                }
                return _op3;
            </grammar>
            <grammar pattern="ParenL Memory id limits ParenR">
                if(!_op2.empty()){
                    if(_this.mem_indices.contains(_op2)){
                        throw Exception::Parse("memory ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
                    }
                    _this.mem_indices.insert(_op2, Parser::IndexMap::Import);
                }else{
                    _this.mem_indices.insert(Parser::IndexMap::Import);
                }
                return _op3;
            </grammar>
            <grammar pattern="ParenL Global id globaltype ParenR">
                if(!_op2.empty()){
                    if(_this.global_indices.contains(_op2)){
                        throw Exception::Parse("global ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
                    }
                    _this.global_indices.insert(_op2, Parser::IndexMap::Import);
                }else{
                    _this.global_indices.insert(Parser::IndexMap::Import);
                }
                return _op3;
            </grammar>
        </target>
        <target name="export" type="WasmExport">
            <grammar pattern="ParenL Export String ParenL Func funcidx ParenR ParenR">
                if(_this.exports.contains(_op2.value)){
                    throw Exception::Parse("export name '" + _op2.value + "' is duplicated", {_pos[2].line, _pos[2].column});
                }
                return WasmExport {.name = _op2.value, .desc = WasmExport::DescType::func, .index = _op5};
            </grammar>
            <grammar pattern="ParenL Export String ParenL Table tableidx ParenR ParenR">
                if(_this.exports.contains(_op2.value)){
                    throw Exception::Parse("export name '" + _op2.value + "' is duplicated", {_pos[2].line, _pos[2].column});
                }
                return WasmExport {.name = _op2.value, .desc = WasmExport::DescType::table, .index = _op5};
            </grammar>
            <grammar pattern="ParenL Export String ParenL Memory memidx ParenR ParenR">
                if(_this.exports.contains(_op2.value)){
                    throw Exception::Parse("export name '" + _op2.value + "' is duplicated", {_pos[2].line, _pos[2].column});
                }
                return WasmExport {.name = _op2.value, .desc = WasmExport::DescType::mem, .index = _op5};
            </grammar>
            <grammar pattern="ParenL Export String ParenL Global globalidx ParenR ParenR">
                if(_this.exports.contains(_op2.value)){
                    throw Exception::Parse("export name '" + _op2.value + "' is duplicated", {_pos[2].line, _pos[2].column});
                }
                return WasmExport {.name = _op2.value, .desc = WasmExport::DescType::global, .index = _op5};
            </grammar>
        </target>
        <target name="importabbr" type="std::optional<std::pair<std::string, std::string>>">
            <grammar pattern="ParenL Import String String ParenR">
                return std::pair\<std::string, std::string> {_op2.value, _op3.value};
            </grammar>
            <grammar>
                return std::nullopt;
            </grammar>
        </target>
        <target name="exportabbr" type="std::vector<std::string>">
            <grammar pattern="exportabbr ParenL Export String ParenR">
                if(_this.exports.contains(_op3.value)){
                    throw Exception::Parse("export name '" + _op3.value + "' is duplicated", {_pos[3].line, _pos[3].column});
                }
                _op0.emplace_back(_op3.value);
                return _op0;
            </grammar>
            <grammar>
                return std::vector\<std::string>();
            </grammar>
        </target>
        <target name="locals" type="std::list<ValueType>">
            <grammar pattern="ParenL Local Id valtype ParenR locals">
                if(_this.local_indices.contains(_op2.value)){
                    throw Exception::Parse("local name '" + _op2.value + "' is duplicated", {_pos[2].line, _pos[2].column});
                }
                _this.local_indices[_op2.value] = _this.local_count;
                _this.local_count += 1;
                _op5.emplace_front(_op3);
                return _op5;
            </grammar>
            <grammar pattern="ParenL Local valtypes ParenR locals">
                _op4.insert(_op4.begin(), _op2.begin(), _op2.end());
                _this.local_count += _op2.size();
                return _op4;
            </grammar>
            <grammar>
                return std::list\<ValueType>();
            </grammar>
        </target>
        <target name="instrs" type="std::vector<WasmInstr>">
            <grammar>
                return std::vector\<WasmInstr>();
            </grammar>
        </target>
        <target name="func" type="std::variant<WasmFunc, WasmImport>">
            <grammar pattern="ParenL Func id exportabbr typeuse locals instrs ParenR">
                index_t index = 0;
                if(_op2.empty()){
                    index = _this.func_indices.insert(Parser::IndexMap::Normal);
                }else{
                    if(_this.func_indices.contains(_op2)){
                        throw Exception::Parse("function ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
                    }
                    index = _this.func_indices.insert(_op2, Parser::IndexMap::Normal);
                }
                for(std::string export_name : _op3){
                    _this.exports[export_name] = WasmExport {.name = export_name, .desc = WasmExport::DescType::func, .index = index};
                }
                _op6.emplace_back(Instr::End());
                return WasmFunc {.typeidx = _op4, .locals = std::vector\<ValueType>(_op5.begin(), _op5.end()), .body = _op6};
            </grammar>
            <grammar pattern="ParenL Func id exportabbr ParenL Import String String ParenR typeuse ParenR">
                index_t index = 0;
                if(_op2.empty()){
                    index = _this.func_indices.insert(Parser::IndexMap::Import);
                }else{
                    if(_this.func_indices.contains(_op2)){
                        throw Exception::Parse("function ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
                    }
                    index = _this.func_indices.insert(_op2, Parser::IndexMap::Import);
                }
                for(std::string export_name : _op3){
                    _this.exports[export_name] = WasmExport {.name = export_name, .desc = WasmExport::DescType::func, .index = index};
                }
                return WasmImport {.module = _op6.value, .name = _op7.value, .desc = _op9};
            </grammar>
        </target>
        <target name="table" type="std::variant<TableType, WasmImport>">
            <grammar pattern="ParenL Table id exportabbr importabbr tabletype ParenR">
                if(_op2.empty()){
                    if(_op4.has_value()){
                        index_t index = _this.table_indices.insert(Parser::IndexMap::Import);
                        for(std::string export_name : _op3){
                            _this.exports[export_name] = WasmExport {.name = export_name, .desc = WasmExport::DescType::table, .index = index};
                        }
                        return WasmImport {.module = _op4->first, .name = _op4->second, .desc = _op5};
                    }else{
                        index_t index = _this.table_indices.insert(Parser::IndexMap::Normal);
                        for(std::string export_name : _op3){
                            _this.exports[export_name] = WasmExport {.name = export_name, .desc = WasmExport::DescType::table, .index = index};
                        }
                        return _op5;
                    }
                }else{
                    if(_this.table_indices.contains(_op2)){
                        throw Exception::Parse("table ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
                    }
                    if(_op4.has_value()){
                        index_t index = _this.table_indices.insert(_op2, Parser::IndexMap::Import);
                        for(std::string export_name : _op3){
                            _this.exports[export_name] = WasmExport {.name = export_name, .desc = WasmExport::DescType::table, .index = index};
                        }
                        return WasmImport {.module = _op4->first, .name = _op4->second, .desc = _op5};
                    }else{
                        index_t index = _this.table_indices.insert(_op2, Parser::IndexMap::Normal);
                        for(std::string export_name : _op3){
                            _this.exports[export_name] = WasmExport {.name = export_name, .desc = WasmExport::DescType::table, .index = index};
                        }
                        return _op5;
                    }
                }
            </grammar>
            {% TODO: inline elem %}
        </target>
        <target name="memory" type="std::variant<Limits, WasmImport>">
            <grammar pattern="ParenL Memory id exportabbr importabbr limits ParenR">
                if(_op2.empty()){
                    if(_op4.has_value()){
                        index_t index = _this.mem_indices.insert(Parser::IndexMap::Import);
                        for(std::string export_name : _op3){
                            _this.exports[export_name] = WasmExport {.name = export_name, .desc = WasmExport::DescType::mem, .index = index};
                        }
                        return WasmImport {.module = _op4->first, .name = _op4->second, .desc = _op5};
                    }else{
                        index_t index = _this.mem_indices.insert(Parser::IndexMap::Normal);
                        for(std::string export_name : _op3){
                            _this.exports[export_name] = WasmExport {.name = export_name, .desc = WasmExport::DescType::mem, .index = index};
                        }
                        return _op5;
                    }
                }else{
                    if(_this.mem_indices.contains(_op2)){
                        throw Exception::Parse("memory ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
                    }
                    if(_op4.has_value()){
                        index_t index = _this.mem_indices.insert(_op2, Parser::IndexMap::Import);
                        for(std::string export_name : _op3){
                            _this.exports[export_name] = WasmExport {.name = export_name, .desc = WasmExport::DescType::mem, .index = index};
                        }
                        return WasmImport {.module = _op4->first, .name = _op4->second, .desc = _op5};
                    }else{
                        index_t index = _this.mem_indices.insert(_op2, Parser::IndexMap::Normal);
                        for(std::string export_name : _op3){
                            _this.exports[export_name] = WasmExport {.name = export_name, .desc = WasmExport::DescType::mem, .index = index};
                        }
                        return _op5;
                    }
                }
            </grammar>
            {% TODO: inline data %}
        </target>
        <target name="global" type="std::variant<WasmGlobal, WasmImport>">
            <grammar pattern="ParenL Global id exportabbr globaltype constexpr ParenR">
                index_t index = 0;
                if(_op2.empty()){
                    index = _this.global_indices.insert(Parser::IndexMap::Normal);
                }else{
                    if(_this.global_indices.contains(_op2)){
                        throw Exception::Parse("global ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
                    }
                    index = _this.global_indices.insert(_op2, Parser::IndexMap::Normal);
                }
                for(std::string export_name : _op3){
                    _this.exports[export_name] = WasmExport {.name = export_name, .desc = WasmExport::DescType::global, .index = index};
                }
                return WasmGlobal {.type = _op4, .init = _op5};
            </grammar>
            <grammar pattern="ParenL Global id exportabbr ParenL Import String String ParenR globaltype ParenR">
                index_t index = 0;
                if(_op2.empty()){
                    index = _this.global_indices.insert(Parser::IndexMap::Import);
                }else{
                    if(_this.global_indices.contains(_op2)){
                        throw Exception::Parse("global ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
                    }
                    index = _this.global_indices.insert(_op2, Parser::IndexMap::Import);
                }
                for(std::string export_name : _op3){
                    _this.exports[export_name] = WasmExport {.name = export_name, .desc = WasmExport::DescType::global, .index = index};
                }
                return WasmImport {.module = _op6.value, .name = _op7.value, .desc = _op9};
            </grammar>
        </target>
    </parser>
</pxml>