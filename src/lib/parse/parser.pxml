<!DOCTYPE pxml>
<pxml>
    <parser class="Parser" headerFile="Parser.hpp" sourceFile="Parser.cpp" start="module" return="WasmModule">
        {% header file %}
        <header indent=0 position="top">
            #include \<structures/WasmModule.hpp>
            #include \<exception.hpp>
            #include \<map>
            #include \<set>
            #include \<vector>
            #include \<utility>
            #include \<algorithm>
        </header>
        {% members %}
        <member>
            struct IndexMap {
                enum IndexType {Import, Normal};
                using Index = std::pair\<IndexType, index_t>;
                struct Compare {
                    bool operator()(const Index& lhs, const Index& rhs) const {
                        if(lhs.first != rhs.first){
                            return lhs.first == IndexType::Import;
                        }
                        return lhs.second \< rhs.second;
                    }
                };
                index_t insert(IndexType type);
                index_t insert(std::string id, IndexType type);
                bool contains(std::string id);
                index_t operator[](index_t index);
                private:
                index_t serial = 0;
                std::set\<Index, Compare> indices;
                std::vector\<std::set\<Index, Compare>::iterator> handlers;
                std::map\<std::string, index_t> id_map;
            };
            std::vector\<std::pair\<FuncType, std::map\<std::string, index_t>>> types;
            std::map\<std::string, index_t> type_indices;
            IndexMap func_indices;
            IndexMap table_indices;
            IndexMap mem_indices;
            IndexMap global_indices;
            void reset();
        </member>
        <source indent=0 position="bottom">
            namespace WasmVM {
            index_t Parser::IndexMap::insert(IndexType type){
                index_t index = handlers.size();
                handlers.emplace_back(indices.emplace(type, serial++).first);
                return index;
            }
            index_t Parser::IndexMap::insert(std::string id, IndexType type){
                if(!id_map.contains(id)){
                    id_map[id] = insert(type);
                }
                return id_map[id];
            }
            bool Parser::IndexMap::contains(std::string id){
                return id_map.contains(id);
            }
            index_t Parser::IndexMap::operator[](index_t index){
                index_t result = 0;
                for(const std::pair\<IndexType, index_t>& index_pair : indices){
                    if(index_pair.second == index){
                        return result;
                    }
                    result += 1;
                }
                return -1;
            }
            void Parser::reset(){
                types.clear();
                type_indices.clear();
                func_indices = IndexMap();
                table_indices = IndexMap();
                mem_indices = IndexMap();
                global_indices = IndexMap();
            }
            } // namespace WasmVM
        </source>
        {% targets %}
        <target name="modulefield" type="WasmModule">
            <grammar pattern="modulefield type">
                return _op0;
            </grammar>
            <grammar pattern="modulefield import">
                _op0.imports.emplace_back(_op1);
                return _op0;
            </grammar>
            <grammar pattern="modulefield table">
                if(std::holds_alternative\<WasmImport>(_op1)){
                    _op0.imports.emplace_back(std::get\<WasmImport>(_op1));
                }else{
                    _op0.tables.emplace_back(std::get\<TableType>(_op1));
                }
                return _op0;
            </grammar>
            <grammar pattern="modulefield memory">
                if(std::holds_alternative\<WasmImport>(_op1)){
                    _op0.imports.emplace_back(std::get\<WasmImport>(_op1));
                }else{
                    _op0.mems.emplace_back(std::get\<Limits>(_op1));
                }
                return _op0;
            </grammar>
            <grammar>
                return WasmModule();
            </grammar>
        </target>
        <target name="module" type="WasmModule">
            <grammar pattern="ParenL Module Id modulefield ParenR">
                for(auto& functype : _this.types){
                    _op3.types.emplace_back(functype.first);
                }
                _this.reset();
                return _op3;
            </grammar>
            <grammar pattern="ParenL Module modulefield ParenR">
                for(auto& functype : _this.types){
                    _op2.types.emplace_back(functype.first);
                }
                _this.reset();
                return _op2;
            </grammar>
            <grammar pattern="modulefield">
                for(auto& functype : _this.types){
                    _op0.types.emplace_back(functype.first);
                }
                _this.reset();
                return _op0;
            </grammar>
            <grammar pattern="ParenL ParenR">
                _this.reset();
                return WasmModule();
            </grammar>
            <grammar pattern="EOF">
                _this.reset();
                return WasmModule();
            </grammar>
        </target>
        <target name="valtype" type="ValueType">
            <grammar pattern="NumType">
                if(_op0.value == "i32"){
                    return ValueType::i32;
                }else if(_op0.value == "i64"){
                    return ValueType::i64;
                }else if(_op0.value == "f32"){
                    return ValueType::f32;
                }else{
                    return ValueType::f64;
                }
            </grammar>
            <grammar pattern="Funcref">
                return ValueType::funcref;
            </grammar>
            <grammar pattern="Externref">
                return ValueType::externref;
            </grammar>
        </target>
        <target name="reftype" type="RefType">
            <grammar pattern="Funcref">
                return RefType::funcref;
            </grammar>
            <grammar pattern="Externref">
                return RefType::externref;
            </grammar>
        </target>
        <target name="valtypes" type="std::vector<ValueType>">
            <grammar pattern="valtypes valtype">
                _op0.emplace_back(_op1);
                return _op0;
            </grammar>
            <grammar>
                return std::vector\<ValueType>();
            </grammar>
        </target>
        <target name="params" type="std::pair<std::vector<ValueType>, std::map<std::string, index_t>>">
            <grammar pattern="params ParenL Param Id valtype ParenR">
                if(_op0.second.contains(_op3.value)){
                    throw Exception::Parse("parameter ID '" + _op3.value + "' is duplicated", {_pos[3].line, _pos[3].column});
                }
                _op0.second.emplace(_op3.value, _op0.first.size());
                _op0.first.emplace_back(_op4);
                return _op0;
            </grammar>
            <grammar pattern="params ParenL Param valtypes ParenR">
                _op0.first.insert(_op0.first.end(), _op3.begin(), _op3.end());
                return _op0;
            </grammar>
            <grammar>
                return std::pair\<std::vector\<ValueType>, std::map\<std::string, index_t>>();
            </grammar>
        </target>
        <target name="results" type="std::vector<ValueType>">
            <grammar pattern="results ParenL Result valtypes ParenR">
                _op0.insert(_op0.end(), _op3.begin(), _op3.end());
                return _op0;
            </grammar>
            <grammar>
                return std::vector\<ValueType>();
            </grammar>
        </target>
        <target name="functype" type="std::pair<FuncType, std::map<std::string, index_t>>">
            <grammar pattern="ParenL Func params results ParenR">
                return {FuncType {.params = _op2.first, .results = _op3}, _op2.second};
            </grammar>
        </target>
        <target name="id" type="std::string">
            <grammar pattern="Id">
                return _op0.value;
            </grammar>
            <grammar>
                return "";
            </grammar>
        </target>
        <target name="type">
            <grammar pattern="ParenL Type id functype ParenR">
                if(!_op2.empty()){
                    if(_this.type_indices.contains(_op2)){
                        throw Exception::Parse("type ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
                    }
                    _this.type_indices[_op2] = _this.types.size();
                }
                _this.types.emplace_back(_op3);
            </grammar>
        </target>
        <target name="u32" type="u32_t">
            <grammar pattern="Integer">
                try{
                    return std::stoul(_op0.value, 0);
                }catch(std::invalid_argument){
                    throw Exception::Parse("invalid u32 integer '" + _op0.value + "'", {_pos[0].line, _pos[0].column});
                }
            </grammar>
        </target>
        <target name="index" type="std::variant<std::string, u32_t>">
            <grammar pattern="u32">
                return _op0;
            </grammar>
            <grammar pattern="Id">
                return _op0.value;
            </grammar>
        </target>
        <target name="typeuse" type="u32_t">
            <grammar pattern="ParenL Type index ParenR params results">
                index_t typeidx = 0;
                if(std::holds_alternative\<std::string>(_op2)){
                    std::string id = std::get\<std::string>(_op2);
                    if(!_this.type_indices.contains(id)){
                        throw Exception::Parse("type ID '" + id + "' not found", {_pos[2].line, _pos[2].column});
                    }
                    typeidx = _this.type_indices[id];
                }else{
                    typeidx = std::get\<index_t>(_op2);
                }
                if(_op4.first.empty() && _op5.empty()){
                    return typeidx;
                }
                std::pair\<FuncType, std::map\<std::string, index_t>> derived = _this.types[typeidx];
                for(auto& id_pair : _op4.second){
                    if(derived.second.contains(id_pair.first)){
                        throw Exception::Parse("parameter ID '" + id_pair.first + "' is duplicated", {_pos[4].line, _pos[4].column});
                    }
                    derived.second[id_pair.first] = id_pair.second + derived.first.params.size();
                }
                derived.first.params.insert(derived.first.params.end(), _op4.first.begin(), _op4.first.end());
                derived.first.results.insert(derived.first.results.end(), _op5.begin(), _op5.end());
                index_t index = _this.types.size();
                _this.types.emplace_back(derived);
                return index;
            </grammar>
            <grammar pattern="params results">
                index_t index = _this.types.size();
                _this.types.emplace_back(FuncType {.params = _op0.first, .results = _op1}, _op0.second);
                return index;
            </grammar>
            <grammar>
                index_t index = _this.types.size();
                _this.types.emplace_back(FuncType(), std::map\<std::string, index_t>());
                return index;
            </grammar>
        </target>
        <target name="limits" type="Limits">
            <grammar pattern="u32">
                return Limits {.min = _op0};
            </grammar>
            <grammar pattern="u32 u32">
                return Limits {.min = _op0, .max = _op1};
            </grammar>
        </target>
        <target name="tabletype" type="TableType">
            <grammar pattern="limits reftype">
                return TableType {.limits = _op0, .reftype = _op1};
            </grammar>
        </target>
        <target name="globaltype" type="GlobalType">
            <grammar pattern="valtype">
                return GlobalType {.mut = GlobalType::constant, .type = _op0};
            </grammar>
            <grammar pattern="ParenL Mut valtype ParenR">
                return GlobalType {.mut = GlobalType::variable, .type = _op2};
            </grammar>
        </target>
        <target name="import" type="WasmImport">
            <grammar pattern="ParenL Import String String importdesc ParenR">
                return WasmImport {.module = _op2.value, .name = _op3.value, .desc = _op4};
            </grammar>
        </target>
        <target name="importdesc" type="std::variant<index_t, TableType, MemType, GlobalType>">
            <grammar pattern="ParenL Func id typeuse ParenR">
                if(!_op2.empty()){
                    if(_this.func_indices.contains(_op2)){
                        throw Exception::Parse("function ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
                    }
                    _this.func_indices.insert(_op2, Parser::IndexMap::Import);
                }else{
                    _this.func_indices.insert(Parser::IndexMap::Import);
                }
                return _op3;
            </grammar>
            <grammar pattern="ParenL Table id tabletype ParenR">
                if(!_op2.empty()){
                    if(_this.table_indices.contains(_op2)){
                        throw Exception::Parse("table ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
                    }
                    _this.table_indices.insert(_op2, Parser::IndexMap::Import);
                }else{
                    _this.table_indices.insert(Parser::IndexMap::Import);
                }
                return _op3;
            </grammar>
            <grammar pattern="ParenL Memory id limits ParenR">
                if(!_op2.empty()){
                    if(_this.mem_indices.contains(_op2)){
                        throw Exception::Parse("memory ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
                    }
                    _this.mem_indices.insert(_op2, Parser::IndexMap::Import);
                }else{
                    _this.mem_indices.insert(Parser::IndexMap::Import);
                }
                return _op3;
            </grammar>
            <grammar pattern="ParenL Global id globaltype ParenR">
                if(!_op2.empty()){
                    if(_this.global_indices.contains(_op2)){
                        throw Exception::Parse("global ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
                    }
                    _this.global_indices.insert(_op2, Parser::IndexMap::Import);
                }else{
                    _this.global_indices.insert(Parser::IndexMap::Import);
                }
                return _op3;
            </grammar>
        </target>
        <target name="table" type="std::variant<TableType, WasmImport>">
            <grammar pattern="ParenL Table id tabletype ParenR">
                if(!_op2.empty()){
                    if(_this.table_indices.contains(_op2)){
                        throw Exception::Parse("table ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
                    }
                    _this.table_indices.insert(_op2, Parser::IndexMap::Normal);
                }else{
                    _this.table_indices.insert(Parser::IndexMap::Normal);
                }
                return _op3;
            </grammar>
            <grammar pattern="ParenL Table id ParenL Import String String ParenR tabletype ParenR">
                if(!_op2.empty()){
                    if(_this.table_indices.contains(_op2)){
                        throw Exception::Parse("table ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
                    }
                    _this.table_indices.insert(_op2, Parser::IndexMap::Import);
                }else{
                    _this.table_indices.insert(Parser::IndexMap::Import);
                }
                return WasmImport {.module = _op5.value, .name = _op6.value, .desc = _op8};
            </grammar>
            {% TODO: inline elem %}
            {% TODO: inline exports %}
        </target>
        <target name="memory" type="std::variant<Limits, WasmImport>">
            <grammar pattern="ParenL Memory id limits ParenR">
                if(!_op2.empty()){
                    if(_this.mem_indices.contains(_op2)){
                        throw Exception::Parse("memory ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
                    }
                    _this.mem_indices.insert(_op2, Parser::IndexMap::Normal);
                }else{
                    _this.mem_indices.insert(Parser::IndexMap::Normal);
                }
                return _op3;
            </grammar>
            <grammar pattern="ParenL Memory id ParenL Import String String ParenR limits ParenR">
                if(!_op2.empty()){
                    if(_this.mem_indices.contains(_op2)){
                        throw Exception::Parse("memory ID '" + _op2 + "' is duplicated", {_pos[2].line, _pos[2].column});
                    }
                    _this.mem_indices.insert(_op2, Parser::IndexMap::Import);
                }else{
                    _this.mem_indices.insert(Parser::IndexMap::Import);
                }
                return WasmImport {.module = _op5.value, .name = _op6.value, .desc = _op8};
            </grammar>
            {% TODO: inline data %}
            {% TODO: inline exports %}
        </target>
    </parser>
</pxml>