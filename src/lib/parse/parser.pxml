<!DOCTYPE pxml>
<pxml>
    <parser class="Parser" headerFile="Parser.hpp" sourceFile="Parser.cpp" start="module" return="WasmModule">
        {% header file %}
        <header indent=0 position="top">
            #include \<structures/WasmModule.hpp>
            #include \<exception.hpp>
            #include \<map>
            #include \<set>
            #include \<vector>
            #include \<utility>
            #include \<algorithm>
        </header>
        {% members %}
        <member>
            struct IndexMap {
                enum IndexType {Import, Normal};
                using Index = std::pair\<IndexType, index_t>;
                struct Compare {
                    bool operator()(const Index& lhs, const Index& rhs) const {
                        if(lhs.first != rhs.first){
                            return lhs.first == IndexType::Import;
                        }
                        return lhs.second \< rhs.second;
                    }
                };
                index_t insert(IndexType type);
                index_t insert(std::string id, IndexType type);
                bool contains(std::string id);
                index_t operator[](index_t index);
                private:
                index_t serial = 0;
                std::set\<Index, Compare> indices;
                std::vector\<std::set\<Index, Compare>::iterator> handlers;
                std::map\<std::string, index_t> id_map;
            };
            std::vector\<std::pair\<FuncType, std::map\<std::string, index_t>>> types;
            std::map\<std::string, index_t> type_indices;
            IndexMap func_indices;
            IndexMap table_indices;
            IndexMap mem_indices;
            IndexMap global_indices;
            void reset();
        </member>
        <source indent=0 position="bottom">
            namespace WasmVM {
            index_t Parser::IndexMap::insert(IndexType type){
                index_t index = handlers.size();
                handlers.emplace_back(indices.emplace(type, serial++).first);
                return index;
            }
            index_t Parser::IndexMap::insert(std::string id, IndexType type){
                if(!id_map.contains(id)){
                    id_map[id] = insert(type);
                }
                return id_map[id];
            }
            bool Parser::IndexMap::contains(std::string id){
                return id_map.contains(id);
            }
            index_t Parser::IndexMap::operator[](index_t index){
                index_t result = 0;
                for(const std::pair\<IndexType, index_t>& index_pair : indices){
                    if(index_pair.second == index){
                        return result;
                    }
                    result += 1;
                }
                return -1;
            }
            void Parser::reset(){
                types.clear();
                type_indices.clear();
                func_indices = IndexMap();
                table_indices = IndexMap();
                mem_indices = IndexMap();
                global_indices = IndexMap();
            }
            } // namespace WasmVM
        </source>
        {% targets %}
        <target name="modulefield" type="WasmModule">
            <grammar pattern="modulefield type">
                return _op0;
            </grammar>
            <grammar pattern="modulefield import">
                _op0.imports.emplace_back(_op1);
                return _op0;
            </grammar>
            <grammar>
                return WasmModule();
            </grammar>
        </target>
        <target name="module" type="WasmModule">
            <grammar pattern="ParenL Module Id modulefield ParenR">
                for(auto& functype : _this.types){
                    _op3.types.emplace_back(functype.first);
                }
                _this.reset();
                return _op3;
            </grammar>
            <grammar pattern="ParenL Module modulefield ParenR">
                for(auto& functype : _this.types){
                    _op2.types.emplace_back(functype.first);
                }
                _this.reset();
                return _op2;
            </grammar>
            <grammar pattern="modulefield">
                for(auto& functype : _this.types){
                    _op0.types.emplace_back(functype.first);
                }
                _this.reset();
                return _op0;
            </grammar>
            <grammar pattern="ParenL ParenR">
                _this.reset();
                return WasmModule();
            </grammar>
            <grammar pattern="EOF">
                _this.reset();
                return WasmModule();
            </grammar>
        </target>
        <target name="valtype" type="ValueType">
            <grammar pattern="NumType">
                if(_op0.value == "i32"){
                    return ValueType::i32;
                }else if(_op0.value == "i64"){
                    return ValueType::i64;
                }else if(_op0.value == "f32"){
                    return ValueType::f32;
                }else{
                    return ValueType::f64;
                }
            </grammar>
            <grammar pattern="Funcref">
                return ValueType::funcref;
            </grammar>
            <grammar pattern="Externref">
                return ValueType::externref;
            </grammar>
        </target>
        <target name="valtypes" type="std::vector<ValueType>">
            <grammar pattern="valtypes valtype">
                _op0.emplace_back(_op1);
                return _op0;
            </grammar>
            <grammar>
                return std::vector\<ValueType>();
            </grammar>
        </target>
        <target name="params" type="std::pair<std::vector<ValueType>, std::map<std::string, index_t>>">
            <grammar pattern="params ParenL Param Id valtype ParenR">
                if(_op0.second.contains(_op3.value)){
                    throw Exception::Parse("parameter ID '" + _op3.value + "' is duplicated", {_pos[3].line, _pos[3].column});
                }
                _op0.second.emplace(_op3.value, _op0.first.size());
                _op0.first.emplace_back(_op4);
                return _op0;
            </grammar>
            <grammar pattern="params ParenL Param valtypes ParenR">
                _op0.first.insert(_op0.first.end(), _op3.begin(), _op3.end());
                return _op0;
            </grammar>
            <grammar>
                return std::pair\<std::vector\<ValueType>, std::map\<std::string, index_t>>();
            </grammar>
        </target>
        <target name="results" type="std::vector<ValueType>">
            <grammar pattern="results ParenL Result valtypes ParenR">
                _op0.insert(_op0.end(), _op3.begin(), _op3.end());
                return _op0;
            </grammar>
            <grammar>
                return std::vector\<ValueType>();
            </grammar>
        </target>
        <target name="functype" type="std::pair<FuncType, std::map<std::string, index_t>>">
            <grammar pattern="ParenL Func params results ParenR">
                return {FuncType {.params = _op2.first, .results = _op3}, _op2.second};
            </grammar>
        </target>
        <target name="type">
            <grammar pattern="ParenL Type Id functype ParenR">
                if(_this.type_indices.contains(_op2.value)){
                    throw Exception::Parse("type ID '" + _op2.value + "' is duplicated", {_pos[2].line, _pos[2].column});
                }
                _this.type_indices[_op2.value] = _this.types.size();
                _this.types.emplace_back(_op3);
            </grammar>
            <grammar pattern="ParenL Type functype ParenR">
                _this.types.emplace_back(_op2);
            </grammar>
        </target>
        <target name="typeuse" type="index_t">
            <grammar pattern="ParenL Type Id ParenR params results">
                if(!_this.type_indices.contains(_op2.value)){
                    throw Exception::Parse("type ID '" + _op2.value + "' not found", {_pos[2].line, _pos[2].column});
                }
                if(_op4.first.empty() && _op5.empty()){
                    return _this.type_indices[_op2.value];
                }
                std::pair\<FuncType, std::map\<std::string, index_t>> derived = _this.types[_this.type_indices[_op2.value]];
                for(auto& id_pair : _op4.second){
                    if(derived.second.contains(id_pair.first)){
                        throw Exception::Parse("parameter ID '" + id_pair.first + "' is duplicated", {_pos[4].line, _pos[4].column});
                    }
                    derived.second[id_pair.first] = id_pair.second + derived.first.params.size();
                }
                derived.first.params.insert(derived.first.params.end(), _op4.first.begin(), _op4.first.end());
                derived.first.results.insert(derived.first.results.end(), _op5.begin(), _op5.end());
                index_t index = _this.types.size();
                _this.types.emplace_back(derived);
                return index;
            </grammar>
            <grammar pattern="params results">
                index_t index = _this.types.size();
                _this.types.emplace_back(FuncType {.params = _op0.first, .results = _op1}, _op0.second);
                return index;
            </grammar>
            <grammar>
                index_t index = _this.types.size();
                _this.types.emplace_back(FuncType(), std::map\<std::string, index_t>());
                return index;
            </grammar>
        </target>
        <target name="import" type="WasmImport">
            <grammar pattern="ParenL Import String String importdesc ParenR">
                return WasmImport {.module = _op2.value, .name = _op3.value, .desc = _op4};
            </grammar>
        </target>
        <target name="importdesc" type="std::variant<index_t, TableType, MemType, GlobalType>">
            <grammar pattern="ParenL Func Id typeuse ParenR">
                if(_this.func_indices.contains(_op2.value)){
                    throw Exception::Parse("function ID '" + _op2.value + "' is duplicated", {_pos[2].line, _pos[2].column});
                }
                _this.func_indices.insert(_op2.value, Parser::IndexMap::Import);
                return _op3;
            </grammar>
            <grammar pattern="ParenL Func typeuse ParenR">
                _this.func_indices.insert(Parser::IndexMap::Import);
                return _op2;
            </grammar>
        </target>
    </parser>
</pxml>