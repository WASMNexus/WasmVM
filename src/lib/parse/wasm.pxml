<!DOCTYPE pxml>
<pxml namespace="WasmVM">
    {% Token %}
    <tokens namespace="Tokens" headerFile="Token.hpp" sourceFile="Token.cpp">
        {% header file %}
        <header indent=0 position="top">
            #include \<string>
            #include \<Types.hpp>
            #include \<exception.hpp>
        </header>
        {% tokens %}
        <token name="ParenL" />
        <token name="ParenR" />
        <token name="Id">
            <type>std::string</type>
        </token>
        <token name="String">
            <type>std::string</type>
        </token>
        <token name="Integer">
            <type>std::string</type>
        </token>
        <token name="Float">
            <type>std::string</type>
        </token>
        <token name="Offset">
            <type>offset_t</type>
        </token>
        <token name="Align">
            <type>align_t</type>
        </token>
        <token name="Module">
            <type>std::string</type>
        </token>
    </tokens>
    {% Lexer %}
    <lexer class="Lexer" newLine="\n" headerFile="Lexer.hpp" sourceFile="Lexer.cpp">
        {% Block comment %}
        <rule id="Block comment" pattern="\(;" push="block-comment" />
        <group name="block-comment">
            <use id="Block comment" />
            <rule pattern=";\)" pop />
            <rule pattern="\(" />
            <rule pattern=";" />
            <rule pattern="." />
            <rule pattern="$">
                throw Exception::Parse("block comment not close", {_pos.line, _pos.column});
            </rule>
        </group>
        {% Line comment %}
        <rule id="Line comment" pattern=";;" push="line-comment" />
        <group name="line-comment">
            <rule pattern="(\n|$)" pop />
            <rule pattern="." />
        </group>
        {% white space %}
        <rule pattern="( |\t|\n|\r)" />
        {% parenthesis %}
        <rule pattern="\(">
            return Token(ParenL(), _pos);
        </rule>
        <rule pattern="\)">
            return Token(ParenR(), _pos);
        </rule>
        {% id %}
        <rule pattern="\$[0-9a-zA-Z!#%&'*+\-./:<=>@_`\|~\$\^\\?]+">
            return Token(Module(), _pos);
        </rule>
        {% string %}
        <rule pattern="\"" push="string" />
        <group name="string">
            <rule pattern="([\x01-\x1f\x7f])">
                throw Exception::Parse("invalid character in string", {_pos.line, _pos.column});
            </rule>
            <rule pattern="$">
                throw Exception::Parse("string not close", {_pos.line, _pos.column});
            </rule>
            <rule pattern="." more />
            <rule pattern="\"" pop>
                return Token(String(_text.substr(0, _text.size() - 1)), _pos);
            </rule>
        </group>
        {% Integer %}
        <rule pattern="[\+\-]?\d[\d_]*">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("integer can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(Integer(_text), _pos);
        </rule>
        <rule pattern="[\+\-]?0x[\da-fA-F][\da-fA-F_]*">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("integer can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(Integer(_text), _pos);
        </rule>
        {% Floating %}
        <rule pattern="[\+\-]?(nan|nan:0x[\da-fA-F][\da-fA-F_]*|inf)">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("floating number can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(Float(_text), _pos);
        </rule>
        <rule pattern="[\+\-]?\d[\d_]*([Ee][\+\-]?\d[\d_]*|\.(\d[\d_]*)?([Ee][\+\-]?\d[\d_]*)?)">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("floating number can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(Float(_text), _pos);
        </rule>
        <rule pattern="[\+\-]?0x[\da-fA-F][\da-fA-F_]*([Pp][\+\-]?\d[\d_]*|\.([\da-fA-F][\da-fA-F_]*)?([Pp][\+\-]?\d[\d_]*)?)">
            // Check underscore
            if(_text.ends_with('_') || (_text.find("__") != std::string::npos)){
                throw Exception::Parse("floating number can't have consecutive '_' or ends with '_'", {_pos.line, _pos.column});
            }
            _text.erase(std::remove(_text.begin(), _text.end(), '_'), _text.end());
            return Token(Float(_text), _pos);
        </rule>
        {% keywords %}
        <rule pattern="module">
            return Token(Module(), _pos);
        </rule>
    </lexer>
</pxml>